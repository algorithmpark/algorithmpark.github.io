

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/algorithmpark.png">
  <link rel="icon" href="/img/algorithmpark.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="CJL">
  <meta name="keywords" content="">
  
    <meta name="description" content="基于王道操作系统考研视频课的笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统笔记">
<meta property="og:url" content="https://blog.algorithmpark.xyz/2024/01/19/operating-system/index/index.html">
<meta property="og:site_name" content="AlgorithmPark">
<meta property="og:description" content="基于王道操作系统考研视频课的笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.algorithmpark.xyz/img/operating-system.png">
<meta property="article:published_time" content="2024-01-19T09:17:40.000Z">
<meta property="article:modified_time" content="2024-06-17T00:10:36.703Z">
<meta property="article:author" content="CJL">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://blog.algorithmpark.xyz/img/operating-system.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>操作系统笔记 - AlgorithmPark</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"blog.algorithmpark.xyz","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":100,"cursorChar":"_","loop":true,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":2},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Algorithm Park</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/old/" target="_self">
                <i class="iconfont icon-plan"></i>
                <span>旧算法乐园</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/banner.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="操作系统笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-01-19 09:17" pubdate>
          2024年1月19日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          23k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          191 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">操作系统笔记</h1>
            
              <p id="updated-time" class="note note-info" style="display: none">
                
                  
                    本文最后更新于 2024-06-17T00:10:36+00:00
                  
                  

                
              </p>
            
            
              <div class="markdown-body">
                
                <h1>操作系统笔记</h1>
<p>考试信息：</p>
<ul>
<li>选择</li>
<li>判断</li>
<li>分析（简答）</li>
<li>大题</li>
</ul>
<p>课后题重要，但没有原题</p>
<p>参考视频：王道操作系统考研</p>
<h2 id="2-1-进程与线程">2.1 进程与线程</h2>
<h3 id="进程的概念、组成、特征">进程的概念、组成、特征</h3>
<ul>
<li>
<p>程序: 是<strong>静态的</strong>,就是个存放在磁盘里的可执行文件,就是一系列的指令集合。</p>
</li>
<li>
<p>进程(Process) :是<strong>动态的</strong>,是程序的一次执行过程</p>
<p>同一个程序多次执行会对应多个进程</p>
</li>
</ul>
<p>进程实体的组成</p>
<ul>
<li>
<p>PCB ：以下信息都被保存在一个数据结构PCB (Process Control Block)中,即进程控制块, 操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息，都会被放在PCB中</p>
<ul>
<li>
<p><strong>进程描述信息</strong>：操作系统要记录进程标识符(PID)、进程所属用户ID（UID)</p>
</li>
<li>
<p><strong>资源分配清单</strong>：还要记录给进程分配了哪些资源（如：分配了多少内存、正在使用哪些I/O设备、正在使用哪些文件）</p>
</li>
<li>
<p><strong>进程控制和管理信息</strong>：还要记录进程的运行情况（如：CPU使用时间、磁盘使用情况、网络流量使用情况等）,</p>
<p>进程当前状态：就绪态/阻塞态/运行态…</p>
</li>
<li>
<p><strong>处理机相关信息</strong>：处理机相关信息如PSW、PC等等各种寄存器的值（用于实现进程切换）</p>
</li>
</ul>
</li>
<li>
<p>程序段：程序的代码（指令序列）</p>
</li>
<li>
<p>数据段：运行过程中产生的各种数据（程序中定义的变量）</p>
</li>
</ul>
<p>进程的特征</p>
<ul>
<li>动态性：进程是程序的一次执行过程，是动态地产生、变化和消亡的</li>
<li>并发性：内存中有多个进程实体,各进程可并发执行</li>
<li>独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位</li>
<li>异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供&quot;进程同步机制&quot;来解决异步问题</li>
<li>结构性：每个进程都会配置一个PCB,结构上看,进程由程序段、数据段、PCB组成</li>
</ul>
<h3 id="进程的状态">进程的状态</h3>
<p>状态包括：（前三个是三种基本状态）</p>
<ul>
<li>运行状态(Running)</li>
<li>就绪状态(Ready)</li>
<li>阻塞状态(Waiting/Blocked)(等待态)</li>
<li>创建状态(New)(新建态)</li>
<li>终止状态(Terminated)(结束态)</li>
</ul>
<p>状态间的转换</p>
<ul>
<li>就绪态—&gt;运行态</li>
<li>运行态—&gt;就绪态</li>
<li>运行态—&gt;阻塞态</li>
<li>阻塞态—&gt;就绪态</li>
</ul>
<p>进程状态的转换：丁字裤模型</p>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240117115154996.png" srcset="/img/loading.gif" lazyload alt="进程状态的转换"></p>
<p>进程PCB中，会有一个变量 state 来表示进程的当前状态。如：</p>
<ul>
<li>1表示创建态</li>
<li>2表示就绪态</li>
<li>3表示运行态…</li>
</ul>
<p>为了对同一个状态下的各个进程进行统一的管理,操作系统会将各个进程的PCB组织起来。</p>
<p>进程的组织：</p>
<ul>
<li>链接方式：类似于链表（大多数操作系统用这个）</li>
</ul>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240117115650220.png" srcset="/img/loading.gif" lazyload alt="进程的组织：链表方式"></p>
<ul>
<li>索引方式</li>
</ul>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240117115757671.png" srcset="/img/loading.gif" lazyload alt="进程的组织：索引方式"></p>
<h3 id="进程控制">进程控制</h3>
<p>进程的控制使用原语</p>
<p>原语的执行具有原子性,即执行过程只能一气呵成,期间不允许被中断。可以用“关中断指令”和“开中断指令”这两个特权指令实现原子性</p>
<h4 id="进程的创建">进程的创建</h4>
<p>创建原语</p>
<ul>
<li>申请空白PCB</li>
<li>为新进程分配所需资源</li>
<li>初始化PCB</li>
<li>将PCB插入就绪队列</li>
</ul>
<p>引起进程创建的事件</p>
<ul>
<li>用户登录：分时系统中，用户登录成功，系统会建立为其建立一个新的进程</li>
<li>作业调度：多道批处理系统中,有新的作业放入内存时,会为其建立一个新的进程</li>
<li>提供服务：用户向操作系统提出某些请求时，会新建一个进程处理该请求</li>
<li>应用请求：由用户进程主动请求创建一个子进程</li>
</ul>
<h4 id="进程的终止">进程的终止</h4>
<p>撤销原语</p>
<ul>
<li>从PCB集合中找到终止进程的PCB</li>
<li>若进程正在运行，立即剥夺CPU，将CPU分配给其他进程</li>
<li>终止其所有子进程</li>
<li>将该进程拥有的所有资源归还给父进程或操作系统</li>
<li>删除PCB</li>
</ul>
<p>引起进程终止的事件</p>
<ul>
<li>正常结束</li>
<li>异常结束</li>
<li>外界干预</li>
</ul>
<h4 id="进程的阻塞">进程的阻塞</h4>
<p>阻塞原语</p>
<ul>
<li>找到要阻塞的进程对应的PCB</li>
<li>保护进程运行现场，将PCB状态信息设置为“阻塞态&quot;，暂时停止进程运行</li>
<li>将PCB插入相应事件的等待队列</li>
</ul>
<p>引起进程阻塞的事件</p>
<ul>
<li>需要等待系统分配某种资源</li>
<li>需要等待相互合作的其他进程完成工作</li>
</ul>
<h4 id="进程的唤醒">进程的唤醒</h4>
<p>唤醒原语</p>
<ul>
<li>在事件等待队列中找到PCB</li>
<li>将PCB从等待队列移除,设置进程为就绪态</li>
<li>将PCB插入就绪队列，等待被调度</li>
</ul>
<p>引起进程唤醒的事件：等待的事件发生</p>
<h4 id="进程的切换">进程的切换</h4>
<p>切换原语</p>
<ul>
<li>将运行环境信息存入PCB</li>
<li>PCB移入相应队列</li>
<li>切换原语选择另一个进程执行，并更新其PCB</li>
<li>根据PCB恢复新进程所需的运行环境</li>
</ul>
<p>引起进程切换的事件</p>
<ul>
<li>当前进程时间片到</li>
<li>有更高优先级的进程到达</li>
<li>当前进程主动阻塞</li>
<li>当前进程终止</li>
</ul>
<h3 id="进程通信">进程通信</h3>
<ul>
<li>共享存储
<ul>
<li>设置一个共享内存区域，并映射到进程的虚拟地址空间</li>
<li>要互斥地访问共享空间(由通信进程自己负责实现互斥)</li>
<li>两种方式
<ul>
<li>基于数据结构（低级）</li>
<li>基于存储区的共享（高级）</li>
</ul>
</li>
</ul>
</li>
<li>消息传递
<ul>
<li>传递结构化的消息(消息头/消息体)</li>
<li>系统提供“发送/接受原语”</li>
<li>两种方式
<ul>
<li>直接通信方式：消息直接挂到接收进程的消息队列里</li>
<li>间接（信箱）通信方式：消息先发到中间体（信箱）</li>
</ul>
</li>
</ul>
</li>
<li>管道通信
<ul>
<li>1,管道只能采用半双工通信,某一时间段内只能实现单向的传输。如果要实现双向同时通信,则需要设置两个管道。</li>
<li>2,各进程要互斥地访问管道(由操作系统实现)</li>
<li>3,当管道写满时，写进程将阻塞，直到读进程将管道中的数据取走，即可唤醒写进程。</li>
<li>4,当管道读空时,读进程将阻塞,直到写进程往管道中写入数据,即可唤醒读进程。</li>
<li>5,管道中的数据一旦被读出,就彻底消失。因此,当多个进程读同一个管道时,可能会错乱。对此,通常有两种解决方案:
<ul>
<li>①一个管道允许多个写进程,一个读进程(2014年408真题高教社官方答案)</li>
<li>②允许有多个写进程,多个读进程,但系统会让各个读进程轮流从管道中读数据(Linux的方案)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="线程的概念">线程的概念</h3>
<p>引入线程后带来的变化</p>
<ul>
<li>资源分配、调度
<ul>
<li>传统进程机制中，进程是资源分配、调度的基本单位</li>
<li>引入线程后，进程是资源分配的基本单位，线程是调度的基本单位</li>
</ul>
</li>
<li>并发性
<ul>
<li>传统进程机制中，只能进程间并发</li>
<li>引入线程后,各线程间也能并发,提升了并发度</li>
</ul>
</li>
<li>系统开销
<ul>
<li>传统的进程间并发,需要切换进程的运行环境,系统开销很大</li>
<li>线程间并发,如果是同一进程内的线程切换,则不需要切换进程环境,系统开销小</li>
<li>引入线程后,并发所带来的系统开销减小</li>
</ul>
</li>
</ul>
<p>线程的属性</p>
<ul>
<li>线程是处理机调度的单位</li>
<li>多CPU计算机中,各个线程可占用不同的CPU</li>
<li>每个线程都有一个线程ID、线程控制块(TCB)</li>
<li>线程也有就绪、阻塞、运行三种基本状态</li>
<li>线程几乎不拥有系统资源</li>
<li>同一进程的不同线程间共享进程的资源</li>
<li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li>
<li>同一进程中的线程切换，不会引起进程切换</li>
<li>不同进程中的线程切换,会引起进程切换</li>
<li>切换同进程内的线程,系统开销很小</li>
<li>切换进程，系统开销较大</li>
</ul>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240403105106094.png" srcset="/img/loading.gif" lazyload alt="对比:单线程进程和多线程进程"></p>
<p><strong>多线程的优点</strong></p>
<ul>
<li>响应性: 如果部分线程被阻塞，仍可以继续执行，这对于用户界<br>
面设计尤其重要，快速响应;</li>
<li>资源共享: 线程共享进程资源，比进程共享内存或消息传递更容<br>
易，允许一个应用程序在同一地址空间内有多个不同的活跃线程;</li>
<li>经济: 比进程创建更便宜，线程切换比上下文切换开销更低。进<br>
程创建是线程创建的几十倍，进程切换比线程切换慢5倍;</li>
<li>可扩展性（可伸缩性）: 线程可以利用多核体系结构;</li>
</ul>
<p><strong>Amdahl定律</strong></p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>S</mi><mi>A</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi>s</mi><mo>+</mo><mfrac><mrow><mn>1</mn><mo>−</mo><mi>s</mi></mrow><mi>N</mi></mfrac></mrow></mfrac></mrow><annotation encoding="application/x-tex">S_A=\frac 1 {s+\frac {1-s}{N}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4015em;vertical-align:-1.0801em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.2649em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0801em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>: 为处理器数量</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>: 指程序中串行部分的工作量占整个程序工作量的比例</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">S_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>:加速比</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mtext>新的性能</mtext><mtext>旧的性能</mtext></mfrac><mo>=</mo><mfrac><mtext>旧运行时间</mtext><mtext>新运行时间</mtext></mfrac><mo>=</mo><msub><mi>S</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">\frac{新的性能}{旧的性能}=\frac{旧运行时间}{新运行时间}=S_A
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">旧的性能</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">新的性能</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">新运行时间</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">旧运行时间</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p><strong>Amdahl定律说明什么?</strong></p>
<p><em>省流:并行计算没有前途</em></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>→</mo><mi mathvariant="normal">∞</mi><mo separator="true">,</mo><mfrac><mrow><mn>1</mn><mo>−</mo><mi>s</mi></mrow><mi>N</mi></mfrac><mo>→</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>S</mi><mi>A</mi></msub><mo>→</mo><mfrac><mn>1</mn><mi>s</mi></mfrac></mrow><annotation encoding="application/x-tex">N \to \infin,\frac{1-s}N\to 0,S_A\to \frac 1s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord">∞</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">S_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>存在上限</p>
<p>对计算机系统的某个部分采用并行优化措施后所获得的计算机性能的提高是有上限的，这个上限取决于串行部分所占的比例</p>
<p>该定律没有考虑到当代多核系统,需要在分母加一项, 表示内核间的通信</p>
<h3 id="线程的实现方式和多线程模型">线程的实现方式和多线程模型</h3>
<h4 id="线程的实现方式">线程的实现方式</h4>
<ul>
<li>
<p>用户级线程：从用户视角能看到的线程，由线程库实现</p>
<p>管理线程的所有工作都由应用程序完成；内核意识不到线程的存在；采用第三方库来创建如pthreads;</p>
<ul>
<li>
<p>优势: 灵活; 可以运行在任何操作系统, 而不必作代码的改变</p>
</li>
<li>
<p>劣势: 只要一个线程执行了系统调用, 整个进程都会被阻塞; 无法充分利用多核</p>
</li>
<li>
<p>解决方案: 套管技术:把一个产生阻塞的系统调用转化为一个非阻塞的系统调用；把应用程序写成一个多进程程序而非多线程程序,每次切换都变成进程间的切换而非线程间切换</p>
</li>
</ul>
</li>
<li>
<p>内核级线程：从操作系统视角看到的线程，由操作系统实现（内核级线程才是处理机分配的单位)</p>
<ul>
<li>优势: 可以充分利用多核资源; 进程中的一个线程阻塞，内核可以调度同一个进程中的另一个线程；</li>
<li>劣势: 需要切换内核模式, 时间开销大</li>
</ul>
</li>
<li>
<p>组合方式：上述两种方式的结合</p>
<p>很复杂, 没有哪个操作系统能做好, 现在的主流操作系统都没有采用这个</p>
</li>
</ul>
<p>线程模型即用户线程与内核线程的对应关系；</p>
<h4 id="多线程模型">多线程模型</h4>
<ul>
<li>一对一模型：
<ul>
<li>一个用户级线程映射到一个内核级线程</li>
<li>优:各个线程可分配到多核处理机并行执行,并发度高</li>
<li>缺:线程管理都需要操作系统支持,开销大</li>
</ul>
</li>
<li>多对一模型：
<ul>
<li>多个用户级线程映射到一个内核级线程</li>
<li>优：线程管理开销小效率高</li>
<li>缺:一个线程阻塞会导致整个进程都被阻塞(并发度低)</li>
</ul>
</li>
<li>多对多模型
<ul>
<li>n个用户级线程映射到m个内核级线程(n≥m)</li>
<li>集二者之所长</li>
</ul>
</li>
</ul>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240403112424666.png" srcset="/img/loading.gif" lazyload alt="用户级线程状态和进程状态之间关系的示例"></p>
<p>多线程分为异步线程和同步线程</p>
<ul>
<li>异步线程: 父子线程同时运行, 数据共享不多</li>
<li>同步线程: 父线程等待子线程结束, 数据共享多</li>
</ul>
<h3 id="线程的状态与转换">线程的状态与转换</h3>
<pre><code class=" mermaid">graph LR;
id1(就绪) --3 被调度程序选中--&gt; id2(运行);
id2 --2 时间用完--&gt; id1;
id3(阻塞) --4 等待的事件发生--&gt;id1;
id2 --1 等待某事件--&gt;id3;
</code></pre>
<p>线程没有挂起态, 因为线程没有自己管理的内存, 而挂起的含义是将内存写入磁盘</p>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240117164701085.png" srcset="/img/loading.gif" lazyload alt="线程的组织与控制"></p>
<h2 id="2-2-处理机调度">2.2 处理机调度</h2>
<h3 id="调度的概念、层次">调度的概念、层次</h3>
<p>调度的三个层次</p>
<table>
<thead>
<tr>
<th></th>
<th>要做什么</th>
<th>调度发生在</th>
<th>发生频率</th>
<th>对进程状态的影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>高级调度(作业调度)</td>
<td>按照某种规则，从后备队列中选择合适的作业将其调入内存,并为其创建进程</td>
<td>外存→内存（面向作业）</td>
<td>最低</td>
<td>无→创建态→就绪态</td>
</tr>
<tr>
<td>中级调度(内存调度)</td>
<td>按照某种规则,从挂起队列中选择合适的进程将其数据调回内存</td>
<td>外存→内存（面向进程）</td>
<td>中等</td>
<td>挂起态→就绪态（阻塞挂起→阻塞态）</td>
</tr>
<tr>
<td>低级调度(进程调度/处理机调度)</td>
<td>按照某种规则,从就绪队列中选择一个进程为其分配处理机</td>
<td>内存→CPU</td>
<td>最高</td>
<td>就绪态→运行态</td>
</tr>
</tbody>
</table>
<p>进程的挂起态与七状态模型</p>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240117195010258.png" srcset="/img/loading.gif" lazyload alt="进程的挂起态与七状态模型"></p>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240410103754217.png" srcset="/img/loading.gif" lazyload alt="七状态模型与三级调度"></p>
<h3 id="进程调度的时机、切换与过程调度方式">进程调度的时机、切换与过程调度方式</h3>
<p>进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。</p>
<p>需要进行进程调度与切换的情况</p>
<ul>
<li>当前运行的进程主动放弃处理机
<ul>
<li>进程正常终止</li>
<li>运行过程中发生异常而终止</li>
<li>进程主动请求阻塞(如等待I/O)</li>
</ul>
</li>
<li>当前运行的进程被动放弃处理机
<ul>
<li>分给进程的时间片用完</li>
<li>有更紧急的事需要处理(如I/O中断)</li>
<li>有更高优先级的进程进入就绪队列</li>
</ul>
</li>
</ul>
<p>不能进行进程调度与切换的情况</p>
<ul>
<li>在处理中断的过程中。中断处理过程复杂，与硬件密切相关,很难做到在中断处理过程中进行进程切换。</li>
<li>进程在操作系统内核程序临界区中。</li>
<li>在原子操作过程中(原语)。原子操作不可中断,要一气呵成(如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列)</li>
</ul>
<p>进程调度的方式</p>
<ul>
<li><strong>非剥夺调度方式</strong>,又称<strong>非抢占方式</strong>。即,只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达,当前进程依然会继续使用处理机,直到该进程终止或主动要求进入阻塞态。</li>
<li><strong>剥夺调度方式</strong>,又称<strong>抢占方式</strong>。当一个进程正在处理机上执行时,如果有一个更重要或更紧迫的进程需要使用处理机,则立即暂停正在执行的进程,将处理机分配给更重要紧迫的那个进程。</li>
</ul>
<p>切换的过程</p>
<ul>
<li>对原来运行进程各种数据的保存</li>
<li>对新的进程各种数据的恢复</li>
</ul>
<h3 id="调度器和闲逛进程">调度器和闲逛进程</h3>
<h4 id="调度器">调度器</h4>
<pre><code class=" mermaid">graph LR;
id1(就绪) --3 被调度程序选中--&gt; id2(运行);
id2 --2 时间用完--&gt; id1;
id3(阻塞) --4 等待的事件发生--&gt;id1;
id2 --1 等待某事件--&gt;id3;
</code></pre>
<p>其中2和3由调度程序引起</p>
<ul>
<li>非抢占式调度策略,只有运行进程阻塞或退出才触发调度程序工作</li>
<li>抢占式调度策略，每个时钟中断或k个时钟中断会触发调度程序工作</li>
</ul>
<h4 id="闲逛进程-idle">闲逛进程(idle)</h4>
<p>调度程序永远的备胎,没有其他就绪进程时,运行闲逛进程</p>
<ul>
<li>优先级最低</li>
<li>可以是0地址指令,占一个完整的指令周期(指令周期末尾例行检查中断)</li>
<li>能耗低</li>
</ul>
<h3 id="调度算法的评价指标">调度算法的评价指标</h3>
<ul>
<li>CPU利用率</li>
</ul>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mi>P</mi><mi>U</mi><mtext>利用率</mtext><mo>=</mo><mfrac><mtext>忙碌的时间</mtext><mtext>总时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">CPU利用率=\frac{忙碌的时间}{总时间}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord cjk_fallback">利用率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">总时间</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">忙碌的时间</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>对于多道程序并发执行的情况，可以用甘特图辅助计算</p>
<ul>
<li>系统吞吐量</li>
</ul>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>系统吞吐量</mtext><mo>=</mo><mfrac><mtext>总共完成了多少道作业</mtext><mtext>总共花了多少时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">系统吞吐量=\frac{总共完成了多少道作业}{总共花了多少时间}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">系统吞吐量</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">总共花了多少时间</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">总共完成了多少道作业</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<ul>
<li>周转时间</li>
</ul>
<p>从作业被提交给系统开始,到作业完成为止的这段时间间隔。</p>
<p>它包括四个部分:</p>
<ul>
<li>
<ul>
<li>作业在外存后备队列上等待作业调度(高级调度)的时间</li>
<li>进程在就绪队列上等待进程调度(低级调度)的时间</li>
<li>进程在CPU上执行的时间</li>
<li>进程等待I/O操作完成的时间</li>
</ul>
</li>
</ul>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>平均周转时间</mtext><mo>=</mo><mfrac><mtext>各作业周转时间之和</mtext><mtext>作业数</mtext></mfrac></mrow><annotation encoding="application/x-tex">平均周转时间=\frac{各作业周转时间之和}{作业数}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">平均周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">作业数</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">各作业周转时间之和</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>带权周转时间</mtext><mo>=</mo><mfrac><mtext>作业周转时间</mtext><mtext>作业实际运行的时间</mtext></mfrac><mo>=</mo><mfrac><mrow><mtext>作业完成时间</mtext><mo>−</mo><mtext>作业提交时间</mtext></mrow><mtext>作业实际运行的时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">带权周转时间=\frac{作业周转时间}{作业实际运行的时间}=\frac{作业完成时间-作业提交时间}{作业实际运行的时间}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">带权周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">作业实际运行的时间</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">作业周转时间</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">作业实际运行的时间</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">作业完成时间</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord cjk_fallback">作业提交时间</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<ul>
<li>
<ul>
<li>对于周转时间相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多,带权周转时间更小，用户满意度更高。</li>
<li>对于实际运行时间相同的两个作业，周转时间短的带权周转时间更小,用户满意度更高。</li>
</ul>
</li>
<li>
<p>等待时间</p>
</li>
</ul>
<p>指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。</p>
<ul>
<li>
<ul>
<li>对于进程来说,等待时间就是指进程建立后等待被服务的时间之和,在等待I/O完成的期间其实进程也是在被服务的,所以不计入等待时间。</li>
<li>对于作业来说,不仅要考虑建立进程后的等待时间,还要加上作业在外存后备队列中等待的时间。</li>
</ul>
</li>
<li>
<p>响应时间</p>
</li>
</ul>
<p>从用户提交请求到首次产生响应所用的时间</p>
<p><strong>优化原则：</strong></p>
<ul>
<li>最大CPU利用率</li>
<li>最大吞吐量</li>
<li>最小周转时间</li>
<li>最小等待时间</li>
<li>最小响应时间</li>
<li>大多数情况下，优化的是平均值；有些情况下优化的是最小值或最大值，也可以最小化方差；</li>
</ul>
<h3 id="调度算法">调度算法</h3>
<h4 id="（1）适用于早期的批处理系统">（1）适用于早期的批处理系统</h4>
<table>
<thead>
<tr>
<th>算法</th>
<th>思想</th>
<th>规则</th>
<th>可抢占？</th>
<th>优点</th>
<th>缺点</th>
<th>考虑到等待时间&amp;运行时间？</th>
<th>会导致饥饿？</th>
</tr>
</thead>
<tbody>
<tr>
<td>FCFS(First Come First Serve)先来先服务</td>
<td>公平</td>
<td>按照作业/进程到达的先后顺序进行服务</td>
<td>否</td>
<td>公平、算法实现简单</td>
<td>缺点：排在长作业（进程）后面的短作业需要等待很长时间,带权周转时间很大,对短作业来说用户体验不好。</td>
<td>等待时间√，运行时间×</td>
<td>不会</td>
</tr>
<tr>
<td>SJF(Shortest Job First)短作业优先 / SPF(Shortest Process First)短进程优先</td>
<td>追求最少的平均等待时间,最少的平均周转时间、最少的平均平均带权周转时间</td>
<td>最短的作业/进程优先得到服务(所谓“最短”,是指要求服务时间最短）</td>
<td>SJF和SPF是非抢占式的算法。但是也有抢占式的版本——最短剩余时间优先算法（SRTN, Shortest Remaining Time Next)</td>
<td>“最短的”平均等待时间、平均周转时间</td>
<td>缺点:不公平。对短作业有利,对长作业不利。可能产生饥饿现象。另外,作业/进程的运行时间是由用户提供的，并不一定真实,不一定能做到真正的短作业优先</td>
<td>等待时间×，运行时间√</td>
<td>会</td>
</tr>
<tr>
<td>HRRN(Highest Response Ratio Next)高相应比优先</td>
<td>要综合考虑作业/进程的等待时间和要求服务的时间</td>
<td>在每次调度时先计算各个作业/进程的响应比,选择响应比最高的作业/进程为其服务</td>
<td>否</td>
<td>综合考虑了等待时间和运行时间(要求服务时间)。等待时间相同时,要求服务时间短的优先(SJF的优点)，要求服务时间相同时，等待时间长的优先（FCFS的优点）。对于长作业来说,随着等待时间越来越久,其响应比也会越来越大，从而避免了长作业饥饿的问题</td>
<td>无</td>
<td>等待时间√，运行时间√</td>
<td>不会</td>
</tr>
</tbody>
</table>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>响应比</mtext><mo>=</mo><mfrac><mrow><mtext>等待时间</mtext><mo>+</mo><mtext>要求服务时间</mtext></mrow><mtext>要求服务时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">响应比=\frac{等待时间+要求服务时间}{要求服务时间}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">响应比</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">要求服务时间</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">等待时间</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord cjk_fallback">要求服务时间</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<h4 id="（2）适用于交互式操作系统">（2）适用于交互式操作系统</h4>
<ul>
<li>
<p>时间片轮转调度算法(RR，Round-Robin)</p>
<ul>
<li>
<p>算法思想：公平地、轮流地为各个进程服务,让每个进程在一定时间间隔内都可以得到响应</p>
</li>
<li>
<p>算法规则：按照各进程到达就绪队列的顺序,轮流让各个进程执行一个时间片(如100ms)。若进程未在一个时间片内执行完,则剥夺处理机,将进程重新放到就绪队列队尾重新排队。</p>
</li>
<li>
<p>用于作业/进程调度：用于进程调度(只有作业放入内存建立了相应的进程后,才能被分配处理机时间片)</p>
</li>
<li>
<p>是否可抢占？若进程未能在时间片内运行完,将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到</p>
</li>
<li>
<p>优缺点：</p>
<p>优点：公平;响应快,适用于分时操作系统;</p>
<p>缺点:   由于高频率的进程切换,因此有一定开销;不区分任务的紧急程度。</p>
</li>
<li>
<p>是否会导致饥饿？不会</p>
</li>
</ul>
</li>
<li>
<p>优先级调度算法</p>
<ul>
<li>
<p>算法思想：随着计算机的发展,特别是实时操作系统的出现,越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</p>
</li>
<li>
<p>算法规则：调度时选择优先级最高的作业/进程</p>
</li>
<li>
<p>用于作业/进程调度：既可用于作业调度,也可用于进程调度。甚至,还会用于在之后会学习的I/O调度中</p>
</li>
<li>
<p>是否可抢占？抢占式、非抢占式都有。做题时的区别在于:非抢占式只需在进程主动放弃处理机时进行调度即可,而抢占式还需在就绪队列变化时,检查是否会发生抢占。</p>
</li>
<li>
<p>优缺点：优点：用优先级区分紧急程度、重要程度,适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。缺点:若源源不断地有高优先级进程到来,则可能导致饥饿</p>
</li>
<li>
<p>是否会导致饥饿？会</p>
</li>
</ul>
</li>
<li>
<p>多级反馈队列调度算法</p>
<ul>
<li>算法思想：对其他调度算法的折中权衡</li>
<li>算法规则：
<ol>
<li>设置多级就绪队列,各级队列优先级从高到低,时间片从小到大</li>
<li>新进程到达时先进入第1级队列,按FCFS原则排队等待被分配时间片,若用完时间片进程还未结束,则进程进入下一级队列队尾,如果此时已经是在最下级的队列,则重新放回该队列队尾</li>
<li>只有第k级队列为空时,才会为k+1级队头的进程分配时间片</li>
</ol>
</li>
<li>用于用于作业/进程调度：用于进程调度</li>
<li>是否可抢占？<strong>抢占式的算法</strong>。在k级队列的进程运行过程中,若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中,因此新进程会抢占处理机,原来运行的进程放回k级队列队尾。</li>
<li>优缺点：
<ul>
<li>对各类型进程相对公平(FCFS的优点)</li>
<li>每个新到达的进程都可以很快就得到响应(RR的优点)</li>
<li>短进程只用较少的时间就可完成(SPF的优点)</li>
<li>不必实现估计进程的运行时间（避免用户作假)</li>
<li>可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程(拓展:可以将因I/O而阻塞的进程重新放回原队列,这样I/0型进程就可以保持较高优先级)</li>
</ul>
</li>
<li>是否会导致饥饿？会</li>
</ul>
</li>
<li>
<p>多级队列调度算法</p>
</li>
</ul>
<p>按照优先级从高到低的队列分别为：</p>
<p>系统进程（如内存管理进程）</p>
<p>交互式进程（如游戏,打字软件）</p>
<p>批处理进程（如AI模型训练）</p>
<p>队列之间可采取固定优先级,或时间片划分固定优先级：高优先级空时低优先级进程才能被调度时间片划分：如三个队列分配时间50%、40%、10%</p>
<p>各队列可采用不同的调度策略，如系统进程队列采用优先级调度，交互式队列采用RR，批处理队列采用FCFS</p>
<h2 id="2-3-进程同步与互斥">2.3 进程同步与互斥</h2>
<h3 id="进程同步、进程互斥">进程同步、进程互斥</h3>
<p><strong>进程同步</strong>：</p>
<p>同步亦称直接制约关系,它是指为完成某种任务而建立的两个或多个进程,这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p>
<p><strong>进程互斥</strong>：</p>
<pre><code class=" mermaid">graph LR;
id1[两种资源共享方式] ---&gt;id2(互斥共享方式)
id1 ---&gt;id3(同时共享方式)
id2 ---&gt;id4[一个时间段内只允许一个进程访问该资源]
id3 ---&gt;id5[允许一个时间段内由多个进程同时对它们进行访问]
</code></pre>
<p>我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备(比如摄像头、打印机)都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</p>
<p>对临界资源的访问,必须互斥地进行。互斥,亦称间接制约关系。进程互斥指当一个进程访问某临界资沙时,另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束,释放该资源之后,另一个进程才能去访问临界资源。</p>
<p><strong>访问临界资源的代码逻辑</strong>：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span> <br>&#123;<br>    entry section; <span class="hljs-comment">//进入区,进入区负责检查是否可进入临界区,若可进入,则应设置正在访问临界资源的标志(可理解为&quot;上锁&quot;)，以阻止其他进程同时进入临界区</span><br>    critical section; <span class="hljs-comment">//临界区,临界区是进程中访问临界资源的代码段，也可称为“临界段”。</span><br>    <span class="hljs-built_in">exit</span> section; <span class="hljs-comment">//退出区,退出区负责解除正在访问临界资源的标志（可理解为“解锁”）</span><br>    remainder section;<span class="hljs-comment">//剩余区</span><br>&#125; <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure>
<p>进入区和退出区是负责实现互斥的代码段</p>
<p>为了实现对临界资源的互斥访问,同时保证系统整体性能,需要遵循以下原则:</p>
<ol>
<li>空闲让进。临界区空闲时,可以允许一个请求进入临界区的进程立即进入临界区;</li>
<li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待</li>
<li>有限等待。对请求访问的进程,应保证能在有限时间内进入临界区(保证不会饥饿)</li>
<li>让权等待。当进程不能进入临界区时,应立即释放处理机,防止进程忙等待。</li>
</ol>
<h3 id="进程互斥的软件实现方法">进程互斥的软件实现方法</h3>
<h4 id="单标志法">单标志法</h4>
<p>也称严格备选(strict Alternation)</p>
<p>算法思想：两个进程在<strong>访问完临界区后</strong>会把使用临界区的权限转交给另一个进程。也就是说<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong></p>
<p>实现代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> turn = <span class="hljs-number">0</span>; <span class="hljs-comment">//turn 表示当前允许进入临界区的进程号</span><br></code></pre></td></tr></table></figure>
<p>P0进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(turn != <span class="hljs-number">0</span>);<br>critical section;<br>turn = <span class="hljs-number">1</span>;<br>remainder section;<br></code></pre></td></tr></table></figure>
<p>P1进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(turn != <span class="hljs-number">1</span>);<br>critical section;<br>turn = <span class="hljs-number">0</span>;<br>remainder section;<br></code></pre></td></tr></table></figure>
<p>该算法可以实现“同一时刻最多只允许一个进程访问临界区”</p>
<p>只能按<code>P0→P1→P0→P1→...</code> 这样轮流访问。这种必须“轮流访问”带来的问题是,如果此时允许进入临界区的进程是P0,而P0一直不访问临界区,那么虽然此时临界区空闲,但是并不允许P1访问。因此,单标志法存在的主要问题是:违背“空闲让进”原则。</p>
<p>如果一个进程想要连续两次访问临界区，这种方法无法实现</p>
<h4 id="双标志先检查法">双标志先检查法</h4>
<p>算法思想：设置一个布尔型数组flag[]，数组中各个元素用来<strong>标记各进程想进入临界区的意愿</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> flag[<span class="hljs-number">2</span>];<br>flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure>
<p>P0进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(flag[<span class="hljs-number">1</span>]);  <span class="hljs-comment">//1</span><br>flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">//2</span><br>critical section;<span class="hljs-comment">//3</span><br>flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>; <span class="hljs-comment">//4</span><br>remainder section;<br></code></pre></td></tr></table></figure>
<p>P1进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(flag[<span class="hljs-number">0</span>]);   <span class="hljs-comment">//5</span><br>flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;   <span class="hljs-comment">//6</span><br>critical section; <span class="hljs-comment">//7</span><br>flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">//8</span><br>remainder section;<br></code></pre></td></tr></table></figure>
<p>按照152637执行，P0和P1会同时访问临界区</p>
<p>双标志先检查法的主要问题是:违反“忙则等待”原则。原因在于,进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后, “上锁”前可能发生进程切换。</p>
<h4 id="双标志后检查法">双标志后检查法</h4>
<p>算法思想:双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁” ,但是这两个操作又无法一气呵成,因此导致了两个进程同时进入临界区的问题。因此,人们又想到先“上锁”后“检查”的方法,来避免上述问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> flag[<span class="hljs-number">2</span>];<br>flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure>
<p>P0进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">//1</span><br><span class="hljs-keyword">while</span>(flag[<span class="hljs-number">1</span>]);  <span class="hljs-comment">//2</span><br>critical section;<span class="hljs-comment">//3</span><br>flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>; <span class="hljs-comment">//4</span><br>remainder section;<br></code></pre></td></tr></table></figure>
<p>P1进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;   <span class="hljs-comment">//5</span><br><span class="hljs-keyword">while</span>(flag[<span class="hljs-number">0</span>]);   <span class="hljs-comment">//6</span><br>critical section; <span class="hljs-comment">//7</span><br>flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">//8</span><br>remainder section;<br></code></pre></td></tr></table></figure>
<p>按照1526的顺序执行，P0和P1都无法进入临界区</p>
<p>双标志后检查法虽然解决了“忙则等待”的问题,但是又违背了“空闲让进”和“有限等待原则,会因各进程都长期无法访问临界资源而产生“饥饿”现象。两个进程都争着想进入临界区,但是谁也不让谁,最后谁都无法进入临界区。</p>
<h4 id="Peterson算法">Peterson算法</h4>
<p>算法思想:结合双标志法、单标志法的思想。如果双方都争着想进入临界区,那可以让进程尝试“孔融让梨” (谦让)。做一个有礼貌的进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> flag[<span class="hljs-number">2</span>];<br>flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br><span class="hljs-type">int</span> turn = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>
<p>P0进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>turn = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(flag[<span class="hljs-number">1</span>] &amp;&amp; turn ==<span class="hljs-number">1</span>);<br>critical section;<br>flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>remainder section;<br></code></pre></td></tr></table></figure>
<p>P1进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>turn = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(flag[<span class="hljs-number">0</span>] &amp;&amp; turn == <span class="hljs-number">0</span>);<br>critical section;<br>flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>remainder section;<br></code></pre></td></tr></table></figure>
<p>Peterson 算法用软件方法解决了进程互斥问题,遵循了空闲让进、忙则等待、有限等待三个原则,但是依然未遵循让权等待的原则（进不了临界区就卡在while循环，而不是让出处理机）。</p>
<h3 id="进程互斥的硬件实现方法">进程互斥的硬件实现方法</h3>
<h4 id="中断屏蔽方法">中断屏蔽方法</h4>
<p>利用“开/关中断指令”实现(与原语的实现思想相同,即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况)</p>
<p>优点：简单、高效</p>
<p>缺点:不适用于多处理机; 只适用于操作系统内核进程,不适用于用户进程(因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险)</p>
<h4 id="TestAndSet指令">TestAndSet指令</h4>
<p>简称TS指令，或TSL指令</p>
<p>简称TS指令,也有地方称为TestAndSetLock指令,或TSL指令TSL指令是用硬件实现的,执行的过程不允许被中断,只能一气呵成。以下是用c语言描述的逻辑</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//布尔型共享变量 lock 表示当前临界区是否被加锁</span><br><span class="hljs-comment">//true 表示已加锁，false 表示未加锁</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">TestAndSet</span> <span class="hljs-params">(<span class="hljs-type">bool</span> *lock)</span>&#123;<br>    <span class="hljs-type">bool</span> old;<br>    old = *lock; <span class="hljs-comment">//old用来存放lock原来的值</span><br>    *lock = <span class="hljs-literal">true</span>;<span class="hljs-comment">//无论之前是否已加锁，都将lock设为true</span><br>    <span class="hljs-keyword">return</span> old;<span class="hljs-comment">//返回lock原来的值</span><br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//以下是使用 TSL 指令实现互斥的算法逻辑</span><br><span class="hljs-keyword">while</span> (TestAndSet (&amp;lock)); <span class="hljs-comment">//&quot;上锁&quot;并&quot;检查”</span><br>临界区代码段..<br>lock = <span class="hljs-literal">false</span>;<span class="hljs-comment">//“解锁”</span><br>剩余区代码段...<br></code></pre></td></tr></table></figure>
<p>优点:</p>
<p>实现简单,无需像软件实现方法那样严格检查是否会有逻辑漏洞</p>
<p>适用于多处理机环境</p>
<p>缺点:</p>
<p>不满足“让权等待”原则,暂时无法进入临界区的进程会占用CPU并循环执行TSL指令,从而导致“忙等”。</p>
<h4 id="Swap指令">Swap指令</h4>
<p>也称为XCHG指令</p>
<p>Swap 指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//以下是用 Swap 指令实现互斥的算法逻辑</span><br><span class="hljs-comment">//lock 表示当前临界区是否被加锁</span><br><span class="hljs-type">bool</span> old = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span> (old== <span class="hljs-literal">true</span>)<br>    Swap (&amp;lock, &amp;old);<br>临界区代码段...<br>lock = <span class="hljs-literal">false</span>;<br>剩余区代码段…..<br></code></pre></td></tr></table></figure>
<p>优缺点同<a href="#TestAndSet%E6%8C%87%E4%BB%A4">TestAndSet指令</a></p>
<h3 id="互斥锁">互斥锁</h3>
<p>互斥锁mutex lock，也称为自旋锁spin lock</p>
<p>特性：</p>
<ul>
<li>需忙等，进程时间片用完才下处理机,违反“让权等待”</li>
<li>优点:等待期间不用切换进程上下文,多处理器系统中,若上锁的时间短,则等待代价很低</li>
<li>常用于多处理器系统,一个核忙等,其他核照常工作,并快速释放临界区</li>
<li>不太适用于单处理机系统，忙等的过程中不可能解锁</li>
</ul>
<h3 id="信号量机制">信号量机制</h3>
<p><strong>信号量</strong>其实就是一个变量(可以是一个整数，也可以是更复杂的记录型变量)，可以用一个信号量来表示系统中某种资源的数量,比如:“系统中只有一台打印机,就可以设置一个初值为1的信号量。</p>
<p><strong>原语</strong>是一种特殊的程序段,其执行只能一气呵成,不可被中断。原语是由关中断/开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”,因此如果能把进入区、退出区的操作都用“原语”实现,使这些操作能“一气呵成”就能避免问题。</p>
<p>一对原语: wait(S)原语和signal(S)原语,可以把原语理解为我们自己写的函数,函数名分别为wait和 signal，括号里的信号量 S 其实就是函数调用时传入的一个参数。</p>
<p>wait、signal原语常简称为P、V操作(来自荷兰语proberen和verhogen)。因此，做题的时候常把wait(S)、 signal(S)两个操作分别写为P(S)、V(S)</p>
<h4 id="整型信号量">整型信号量</h4>
<ul>
<li>用一个整数型变量作为信号量，数值表示某种资源数</li>
<li>整型信号量与普通整型变量的区别：对信号量只能执行 初始化、P、V 三种操作</li>
<li>整型信号量存在的问题：不满足让权等待原则</li>
</ul>
<h4 id="记录型信号量">记录型信号量</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*记录型信号量的定义*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> value;<span class="hljs-comment">//剩余资源数</span><br>    Struct process *L; <span class="hljs-comment">//等待队列</span><br>&#125; semaphore;<br><span class="hljs-comment">/*某进程需要使用资源时,通过 wait 原语申请*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">wait</span> <span class="hljs-params">(semaphore S)</span> &#123;<br>    S.value--;<br>    <span class="hljs-keyword">if</span> (S.value &lt; <span class="hljs-number">0</span> ) &#123; <br>        block (S.L);<span class="hljs-comment">//自我阻塞，将当前运行的进程从运行态变为阻塞态</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">/*进程使用完资源后,通过 signal 原语释放*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">signal</span> <span class="hljs-params">(semaphore S)</span>&#123;<br>    S.value++;<br>    <span class="hljs-keyword">if</span> (S.value &lt;= <span class="hljs-number">0</span>) &#123;<br>        wakeup(S.L);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//进程代码</span><br>...<br>wait(S);<br>使用打印机<br>signal(S);<br>...<br></code></pre></td></tr></table></figure>
<h3 id="用信号量实现进程互斥、同步、前驱关系">用信号量实现进程互斥、同步、前驱关系</h3>
<h4 id="实现进程互斥">实现进程互斥</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore mutex=<span class="hljs-number">1</span>;<span class="hljs-comment">//初始化信号量</span><br>P1()&#123;<br>    P(mutex);<span class="hljs-comment">//使用临界资源前加锁</span><br>    临界区代码;<br>    V(mutex);<span class="hljs-comment">//使用临界资源后解锁</span><br>&#125;<br>P2()&#123;<br>    P(mutex);<br>    临界区代码;<br>    V(mutex);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="实现进程同步">实现进程同步</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*信号量机制实现同步*/</span><br>semaphore S=<span class="hljs-number">0</span>; <span class="hljs-comment">//初始化同步信号量，初始值为0</span><br>P1()&#123;<br>    代码<span class="hljs-number">1</span>;<br>    代码<span class="hljs-number">2</span>;<br>    V(S);<br>    代码<span class="hljs-number">3</span>;<br>&#125;<br>P2()&#123;<br>    P(S);<br>    代码<span class="hljs-number">4</span>;<br>    代码<span class="hljs-number">5</span>;<br>    代码<span class="hljs-number">6</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以保证代码4一定在代码2之后执行</p>
<h4 id="实现前驱关系">实现前驱关系</h4>
<pre><code class=" mermaid">graph TD;
id1(S1)--a--&gt;id2(S2)
id1 --b--&gt; id3(S3)
id2--c--&gt;id4(S4)
id2 --d--&gt; id5(S5)
id4--e--&gt;id6(S6)
id5--f--&gt;id6
id3--g--&gt;id6
</code></pre>
<p>实现方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c">P1()&#123;<br>    S1;<br>    V(a);<br>    V(b);<br>&#125;<br>P2()&#123;<br>    P(a);<br>    S2;<br>    V(c);<br>    V(d);<br>&#125;<br>P3()&#123;<br>    P(b);<br>    S3;<br>    V(g);<br>&#125;<br>P4()&#123;<br>    P(c);<br>    S4;<br>    V(e);<br>&#125;<br>P5()&#123;<br>    P(d);<br>    S5;<br>    V(f);<br>&#125;<br>P6()&#123;<br>    P(e);<br>    P(f);<br>    P(g);<br>    S6;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="生产者-消费者问题">生产者-消费者问题</h3>
<p>系统中有一组生产者进程和一组消费者进程,生产者进程每次生产一个产品放入缓冲区,消费者进程每次从缓冲区中取出一个产品并使用。(注:这里的“产品”理解为某种数据)</p>
<p>生产者、消费者共享一个初始为空、大小为n的缓冲区。</p>
<ul>
<li>
<p>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。</p>
</li>
<li>
<p>只有缓冲区不空时,消费者才能从中取出产品,否则必须等待。</p>
</li>
<li>
<p>缓冲区是临界资源，各进程必须互斥地访问。</p>
</li>
</ul>
<pre><code class=" mermaid">graph LR;
id1[有产品,缓冲区没空,V]--full--&gt;id2[P,消费者消费];
id3[缓冲区没满,V]--empty--&gt;id4[P,生产者生产]
</code></pre>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore mutex = <span class="hljs-number">1</span>; <span class="hljs-comment">//互斥信号量,实现对缓冲区的互斥访问</span><br>semaphore empty = n; <span class="hljs-comment">//同步信号量,表示空闲缓冲区的数量</span><br>semaphore full = <span class="hljs-number">0</span>;<span class="hljs-comment">//同步信号量,表示产品的数量,也即非空缓冲区的数量</span><br>producer()&#123;<span class="hljs-comment">//生产者</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    	生产一个产品;<br>    	P(empty);<span class="hljs-comment">//消耗一个空闲缓冲区</span><br>    	P(mutex);<br>    	把产品放入缓冲区;<br>    	V(mutex);<br>    	V(full);<span class="hljs-comment">//增加一个产品</span><br>    &#125;<br>&#125;<br>consumer()&#123;<span class="hljs-comment">//消费者</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        P(full);<span class="hljs-comment">//消耗一个产品</span><br>        P(mutex);<br>        从缓冲区取出一个产品;<br>        V(mutex);<br>        V(empty);<span class="hljs-comment">//增加一个空闲缓冲区</span><br>        使用产品;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>为了避免死锁，实现互斥的P操作一定要在实现同步的P操作之后。</p>
<p>上面的例子中，如果颠倒<code>P(empty);</code>和<code>P(mutex);</code>的顺序就会造成死锁</p>
<p>但是<code>V(mutex);</code>和<code>V(full);</code>的顺序可以交换</p>
<p>生产产品和使用产品的代码可以放在PV操作之间，但是为了让临界区的代码尽可能短，一般不会将这些代码放在PV操作之间</p>
<h3 id="多生产者-多消费者问题">多生产者-多消费者问题</h3>
<p>桌子上有一只盘子,每次只能向其中放入一个水果。</p>
<p>爸爸专向盘子中放苹果,妈妈专向盘子中放橘子,儿子专等着吃盘子中的橘子,女儿专等着吃盘子中的苹果。</p>
<p>只有盘子空时,爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时,儿子或女儿可以从盘子中取出水果。</p>
<p>互斥关系：对缓冲区(盘子)的访问要互斥地进行</p>
<p>同步关系（一前一后）：</p>
<ol>
<li>
<p>父亲将苹果放入盘子后,女儿才能取苹果</p>
</li>
<li>
<p>母亲将橘子放入盘子后,儿子才能取橘子</p>
</li>
<li>
<p>只有盘子为空时,父亲或母亲才能放入水果</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore mutex = <span class="hljs-number">1</span>; <span class="hljs-comment">//实现互斥访问盘子(缓冲区)</span><br>semaphore apple = <span class="hljs-number">0</span>; <span class="hljs-comment">//盘子中有几个苹果</span><br>semaphore orange = <span class="hljs-number">0</span>; <span class="hljs-comment">//盘子中有几个橘子</span><br>semaphore plate = <span class="hljs-number">1</span>;<span class="hljs-comment">//盘子中还可以放多少个水果</span><br>dad()&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        准备一个🍎;<br>        P(plate);<br>        P(mutex);<br>        把🍎放入盘子;<br>        V(mutex);<br>        V(apple);<br>    &#125;<br>&#125;<br>mom()&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        准备一个🍊;<br>        P(plate);<br>        P(mutex);<br>        把🍊放入盘子;<br>        V(mutex);<br>        V(orange);<br>    &#125;<br>&#125;<br>daughter()&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        P(apple);<br>        P(mutex);<br>        从盘中取走🍎;<br>        V(mutex);<br>        V(plate);<br>        吃掉🍎;<br>    &#125;<br>&#125;<br>son()&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        P(orange);<br>        P(mutex);<br>        从盘中取走🍊;<br>        V(mutex);<br>        V(plate);<br>        吃掉🍊;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，不用mutex，也可以实现对盘子的互斥访问</p>
<h3 id="吸烟者问题">吸烟者问题</h3>
<p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它,但是要卷起并抽掉一支烟,抽烟者需要有三种材料:烟草、纸和胶水。</p>
<p>三个抽烟者中,第一个拥有烟草、第二个拥有纸、第三个拥有胶水。</p>
<p>供应者进程无限地提供三种材料,供应者每次将两种材料放桌子上, 拥有剩下那种材料的抽烟者卷一根烟并抽掉它,并给供应者进程一个信号告诉完成了,供应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）</p>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240123153351132.png" srcset="/img/loading.gif" lazyload alt="image-20240123153351132"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore offer1 = <span class="hljs-number">0</span>; <span class="hljs-comment">//桌上组合一的数量</span><br>semaphore offer2 = <span class="hljs-number">0</span>; <span class="hljs-comment">//桌上组合二的数量</span><br>semaphore offer3 = <span class="hljs-number">0</span>; <span class="hljs-comment">//桌上组合三的数量</span><br>semaphore finish = <span class="hljs-number">0</span>; <span class="hljs-comment">//抽烟是否完成</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">//用于实现“三个抽烟者轮流抽烟”</span><br>provider()&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)&#123;<br>            把组合一放在桌儿上;<br>            V(offer1);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)&#123;<br>            把组合二放在桌儿上;<br>            V(offer2);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            把组合三放在桌儿上;<br>            V(offer3);<br>        &#125;<br>    &#125;<br>    i=(i+<span class="hljs-number">1</span>)%<span class="hljs-number">3</span>;<br>    P(finish);<br>&#125;<br>smoker1()&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        P(offer1);<br>        从桌上拿走组合一;卷烟;抽掉;<br>        V(finish);<br>    &#125;<br>&#125;<br>smoker2()&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        P(offer2);<br>        从桌上拿走组合二;卷烟;抽掉;<br>        V(finish);<br>    &#125;<br>&#125;<br>smoker3()&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        P(offer3);<br>        从桌上拿走组合三;卷烟;抽掉;<br>        V(finish);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="读者写者问题">读者写者问题</h3>
<p>有读者和写者两组并发进程,共享一个文件。</p>
<p>当两个或两个以上的读进程同时访问共享数据时不会产生副作用,但若某个写进程和其他进程(读进程或写进程)同时访问共享数据时则可能导致数据不一致的错误。</p>
<p>因此要求:</p>
<ol>
<li>
<p>允许多个读者可以同时对文件执行读操作;</p>
</li>
<li>
<p>只允许一个写者往文件中写信息</p>
</li>
<li>
<p>任一写者在完成写操作之前不允许其他读者或写者工作</p>
</li>
<li>
<p>写者执行写操作前,应让已有的读者和写者全部退出。</p>
</li>
</ol>
<p>实现代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore rw=<span class="hljs-number">1</span>;<span class="hljs-comment">//用于实现对共享文件的互斥访问</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录当前有几个读进程在访问文件</span><br>semaphore mutex = <span class="hljs-number">1</span>;<span class="hljs-comment">//用于保证对count变量的互斥访问</span><br>semaphore w = <span class="hljs-number">1</span>;<span class="hljs-comment">//用于实现“读写公平”</span><br>writer()&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        P(w);<br>        P(rw);<br>        写文件;<br>        V(rw);<br>        V(w);<br>    &#125;<br>&#125;<br>reader()&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        P(w);<br>        P(mutex);<br>        <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span>)<br>            P(rw);<br>        count++;<br>        V(mutex);<br>        V(w);<br>        读文件;<br>        P(mutex);<br>        count--;<br>        <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span>)<br>            V(rw);<br>        V(mutex);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="哲学家进餐问题">哲学家进餐问题</h3>
<p>一张圆桌上坐着5名哲学家,每两个哲学家之间的桌上摆一根筷子,桌子的中间是一碗米饭。</p>
<p>哲学家们倾注毕生的精力用于思考和进餐,哲学家在思考时,并不影响他人。只有当哲学家饥饿时,才试图拿起左、右两根筷子(一根一根地拿起)。</p>
<p>如果筷子已在他人手上,则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐,当进餐完毕后,放下筷子继续思考。</p>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240124160526493.png" srcset="/img/loading.gif" lazyload alt="哲学家进餐"></p>
<p>要求：避免死锁</p>
<p>解决方案</p>
<p>①可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的</p>
<p>②要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子,而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子,另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。</p>
<p>③仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。</p>
<h3 id="管程">管程</h3>
<p>为什么要引入管程？</p>
<p>解决信号量机制编程麻烦、易出错的问题</p>
<p>组成：</p>
<ul>
<li>共享数据结构</li>
<li>组成对数据结构初始化的语句</li>
<li>一组用来访问数据结构的过程（函数)</li>
</ul>
<p>基本特征：</p>
<ul>
<li>各外部进程/线程只能通过管程提供的特定“入口&quot;才能访问共享数据</li>
<li>每次仅允许一个进程在管程内执行某个内部过程</li>
</ul>
<p>补充：</p>
<ul>
<li>各进程必须互斥访问管程的特性是由编译器实现的</li>
<li>可在管程中设置条件变量及等待/唤醒操作以解决同步问题</li>
</ul>
<h3 id="面包师算法">面包师算法</h3>
<p>伪代码：</p>
<p>可能会用<code>(Number[j], j) &lt; (Number[i], i)</code>代替<code>number[j] &lt; number[i] || (number[j] == number[i] &amp;&amp; j &lt; i)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">Entering: <span class="hljs-built_in">array</span> [<span class="hljs-number">1.</span>.NUM_THREADS] of <span class="hljs-type">bool</span> = &#123;<span class="hljs-literal">false</span>&#125;;  <br>Number: <span class="hljs-built_in">array</span> [<span class="hljs-number">1.</span>.NUM_THREADS] of integer = &#123;<span class="hljs-number">0</span>&#125;;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">(integer i)</span> &#123;      <br>  Entering[i] = <span class="hljs-literal">true</span>;<br>  Number[i] = <span class="hljs-number">1</span> + max(Number[<span class="hljs-number">1</span>], ..., Number[NUM_THREADS]);<br>  Entering[i] = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">for</span> (integer j = <span class="hljs-number">1</span>; j &lt;= NUM_THREADS; j++) &#123; <br>    <span class="hljs-comment">// Wait until thread j receives its number:</span><br>    <span class="hljs-keyword">while</span> (Entering[j]) &#123;&#125; <br>    <span class="hljs-comment">// Wait until all threads with smaller numbers or with the same          </span><br>    <span class="hljs-comment">// number, but with higher priority, finish their work:</span><br>    <span class="hljs-keyword">while</span> ((Number[j] != <span class="hljs-number">0</span>) &amp;&amp; (number[j] &lt; number[i] || (number[j] == number[i] &amp;&amp; j &lt; i))) &#123;&#125;      <br>  &#125;  <br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(integer i)</span> &#123;  <br>  Number[i] = <span class="hljs-number">0</span>;  <br>&#125;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">Thread</span><span class="hljs-params">(integer i)</span> &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    lock(i);<br>    <span class="hljs-comment">// The critical section goes here...          </span><br>    unlock(i);<br>    <span class="hljs-comment">// non-critical section...      </span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当一个线程想要进入临界区时，它必须检查轮到它了。它应该检查每个其他线程的Number值，以确保它是最大的。如果另一个线程具有相同的Number值，则具有最小编号的线程将首先进入临界区。</p>
<p>每个线程只写自己的存储，只读共享。值得注意的是，该算法不是建立在一些较低级别的“原子”操作之上。因此，该算法可用于在缺少同步原语的存储器上实现互斥</p>
<p>数组Entering是必要的，假设变量被删除，两个进程计算相同的Number [i]。如果在设置Number [i]之前优先级较高的进程被抢占，则低优先级进程将看到另一个进程的数量为零，并进入临界区;之后，高优先级进程将忽略较低优先级进程的相等Number [i]，并进入临界区。结果，两个进程可以同时进入临界区。</p>
<p>如果不使用Entering数组，假设最开始总共2个进程，它们的Number值都是0</p>
<table>
<thead>
<tr>
<th>进程号</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>Number值</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>进程0首先开始执行lock，当执行完第5行，它计算出<code> 1 + max(Number[1], ..., Number[NUM_THREADS])</code>的值为1，但是没有写回<code>Number[0]</code>时，它被进程1抢占了。</p>
<p>进程1执行完lock没有被打断，进入临界区继续执行，此时的Number表如下</p>
<table>
<thead>
<tr>
<th>进程号</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>Number值</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>现在进程0被唤醒，它继续lock操作，把1写回<code>Number[0]</code>，此时的Number表如下</p>
<table>
<thead>
<tr>
<th>进程号</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>Number值</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>进程0现在执行第12行代码，它没有被阻塞，也进入了临界区，互斥性被违背了。</p>
<h2 id="2-4-死锁">2.4 死锁</h2>
<p>当一组进程中的每个进程都在等待某个事件（资源)，而仅有这组进程中被阻塞的其他进程才可触发该事件时，则认为该组进程发生了死锁。</p>
<p>资源分为可重用资源（使用后不会耗尽）和消费型资源（例如中断信号）</p>
<p>进程使用资源的正确顺序：申请、使用、释放</p>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240126163425186.png" srcset="/img/loading.gif" lazyload alt="死锁"></p>
<h3 id="死锁发生条件">死锁发生条件</h3>
<p>死锁发生的必要条件</p>
<ul>
<li>互斥：一次只有一个进程使用一个资源，其他进程不能访问分配给其他进程的资源</li>
<li>占有等待：当一个进程等待其他进程时,继续占有已分配的资源</li>
<li>非抢占：不能强行抢占进程已占有的资源</li>
<li>循环等待：存在一个闭合的进程链，每个进程至少占有此链中下一个进程所需的一个资源</li>
</ul>
<h3 id="资源分配图">资源分配图</h3>
<p>表示进程和资源的关系：请求和分配</p>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240506083318544.png" srcset="/img/loading.gif" lazyload alt="资源分配图"></p>
<ul>
<li>如果资源分配图中没有环，那么系统就没有进程死锁。</li>
<li>如果有环，可能存在死锁（并非一定死锁，如果资源实例有多个，资源足够，就不会发生死锁）</li>
</ul>
<h3 id="预防死锁">预防死锁</h3>
<p>破坏上述四个条件的任何一个</p>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240126171410797.png" srcset="/img/loading.gif" lazyload alt="image-20240126171410797"></p>
<h4 id="破坏互斥条件">破坏互斥条件</h4>
<p>如果把只能互斥使用的资源改造为允许共享使用,则系统不会进入死锁状态。</p>
<p>比如:<code>SPOOLing</code>技术。操作系统可以采用<code>SPOOLing</code>技术把独占设备在逻辑上改造成共享设备。比如,用<code>SPOOLing</code>技术将打印机改造为共享设备…</p>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240126165335095.png" srcset="/img/loading.gif" lazyload alt="image-20240126165335095"></p>
<p>该策略的缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件。</p>
<h4 id="破坏不剥夺条件">破坏不剥夺条件</h4>
<p><strong>不剥夺条件:</strong></p>
<p>进程所获得的资源在未使用完之前,不能由其他进程强行夺走,只能主动释放。</p>
<p><strong>破坏不剥夺条件</strong>：</p>
<p>方案一:</p>
<p>当某个进程请求新的资源得不到满足时,它必须立即释放保持的所有资源,待以后需要时再重新申请。也就是说,即使某些资源尚未使用完,也需要主动释放,从而破坏了不可剥夺条件。</p>
<p>方案二:</p>
<p>当某个进程需要的资源被其他进程所占有的时候,可以由操作系统协助,将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级(比如:剥夺调度方式,就是将处理机资源强行剥夺给优先级更高的进程使用)</p>
<p><strong>该策略的缺点</strong>：</p>
<ol>
<li>实现起来比较复杂。</li>
<li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。</li>
<li>反复地申请和释放资源会增加系统开销,降低系统吞吐量</li>
<li>若采用方案一,意味着只要暂时得不到某个资源,之前获得的那些资源就都需要放弃,以后再重新申请。如果一直发生这样的情况,就会导致进程饥饿。</li>
</ol>
<h4 id="破坏请求和保持条件">破坏请求和保持条件</h4>
<p><strong>请求和保持条件</strong>：</p>
<p>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</p>
<p>可以采用<strong>静态分配方法</strong>,即进程在运行前一次申请完它所需要的全部资源,在它的资源未满足前,不让它投入运行。一旦投入运行后,这些资源就一直归它所有,该进程就不会再请求别的任何资源了。</p>
<p>该策略实现起来简单,但也有明显的<strong>缺点</strong>:</p>
<p>有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费,资源利用率极低。另外,该策略也有可能导致某些进程饥饿。</p>
<pre><code class=" mermaid">graph LR;
id1(A类进程) ---&gt; id2[资源1]
id5(C类进程) ---&gt; id2
id5 ---&gt;id4
id3(B类进程) ---&gt; id4[资源2]
</code></pre>
<h4 id="破坏循环等待条件">破坏循环等待条件</h4>
<p>循环等待条件:</p>
<p>存在一种进程资源的循环等待链,链中的每一个进程已获得的资源同时被下一个进程所请求。</p>
<p>可采用顺序资源分配法。首先给系统中的资源编号,规定每个进程必须按编号递增的顺序请求资源,同类资源(即编号相同的资源)一次申请完。</p>
<p>原理分析:一个进程只有已占有小编号的资源时,才有资格申请更大编号的资源。按此规则,已持有大编号资源的进程不可能逆向地回来申请小编号的资源,从而就不会产生循环等待的现象。</p>
<p>该策略的缺点：</p>
<ol>
<li>不方便增加新的设备,因为可能需要重新分配所有的编号</li>
<li>进程实际使用资源的顺序可能和编号递增顺序不一致,会导致资源浪费</li>
<li>必须按规定次序申请资源,用户编程麻烦。</li>
</ol>
<h3 id="处理死锁">处理死锁</h3>
<p>死锁预防的副作用是设备使用率低，系统吞吐率低</p>
<p>处理死锁有以下方案</p>
<ul>
<li>确保系统永远不会进入死锁状态
<ul>
<li>死锁预防</li>
<li>死锁避免</li>
</ul>
</li>
<li>允许系统进入死锁状态,然后检测和恢复</li>
<li>忽略该问题,并假装系统中从未发生死锁
<ul>
<li>绝大多数操作系统所采用的的方法</li>
</ul>
</li>
</ul>
<h3 id="资源分配图算法">资源分配图算法</h3>
<p>仅当将申请边转换为分配边不会导致资源分配图中形成循环时,才能授予请求,利用环检测算法,检查安全性</p>
<ul>
<li>需求边Pi-&gt; Rj表示进程Pi可以请求资源Rj，用虚线表示</li>
<li>当进程请求资源时,需求边转换为请求边</li>
<li>将资源分配给进程时,请求边转换为分配边</li>
<li>当流程释放资源时,分配边将重新转换为需求边</li>
<li>必须在系统中预先声明资源</li>
<li>只有当进程Pi的所有边都为需求边时,才能允许将需求边增加到图中</li>
</ul>
<h3 id="银行家算法">银行家算法</h3>
<p>银行家算法是荷兰学者Dijkstra为银行系统设计的,以确保银行在发放现金贷款时,不会发生不能满足所有客户需要的情况。后来该算法被用在操作系统中，用于避免死锁。</p>
<p>核心思想:在进程提出资源申请时,先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态,就暂时不答应这次请求,让该进程先阻塞等待。</p>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240126173222368.png" srcset="/img/loading.gif" lazyload alt="银行家算法"></p>
<p>银行家算法步骤:</p>
<p>①检查此次申请是否超过了之前声明的最大需求数</p>
<p>②检查此时系统剩余的可用资源是否还能满足这次请求</p>
<p>③试探着分配，更改各数据结构</p>
<p>④用安全性算法检查此次分配是否会导致系统进入不安全状态</p>
<h3 id="死锁的检测和解除">死锁的检测和解除</h3>
<p><strong>检测死锁的算法</strong>：</p>
<p>数据结构: 资源分配图</p>
<p>1)在资源分配图中,找出既不阻塞又不是孤点的进程Pi (即找出一条有向边与它相连,且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。若所有的连接该进程的边均满足上述条件,则这个进程能继续运行直至完成,然后释放它所占有的所有资源)。消去它所有的请求边和分配边,使之称为孤立的结点。</p>
<p>2)进程Pi所释放的资源,可以唤醒某些因等待这些资源而阻塞的进程,原来的阻塞进程可能变为非阻塞进程。根据 1)中的方法进行一系列简化后,若能消去途中所有的边,则称该图是可完全简化的。</p>
<p>死锁定理:如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁</p>
<p><strong>死锁的解除</strong></p>
<ol>
<li>
<p>资源剥夺法。挂起(暂时放到外存上)某些死锁进程,并抢占它的资源,将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</p>
</li>
<li>
<p>撤销进程法(或称终止进程法)。强制撤销部分、甚至全部死锁进程,并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间,已经接近结束了,一旦被终止可谓功亏一篑,以后还得从头再来。</p>
</li>
<li>
<p>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</p>
</li>
</ol>
<p><strong>决定对哪个进程动手</strong></p>
<ol>
<li>进程优先级</li>
<li>已执行多长时间</li>
<li>还要多久能完成</li>
<li>进程已经使用了多少资源</li>
<li>进程是交互式的还是批处理式的</li>
</ol>
<h2 id="3-1-内存">3.1 内存</h2>
<h3 id="基础知识">基础知识</h3>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240126180906116.png" srcset="/img/loading.gif" lazyload alt="内存基础知识"></p>
<h3 id="内存管理">内存管理</h3>
<p>内存保护:</p>
<p>方法一：在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。</p>
<p>方法二:采用重定位寄存器(又称基址寄存器)和界地址寄存器（又称限长寄存器）进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。</p>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240126181656279.png" srcset="/img/loading.gif" lazyload alt="内存管理"></p>
<h3 id="覆盖与交换">覆盖与交换</h3>
<p>解决内存大小不够的问题</p>
<h4 id="覆盖技术">覆盖技术</h4>
<p>覆盖技术的思想:将程序分为多个段(多个模块)。常用的段常驻内存,不常用的段在需要时调入内存。</p>
<p>内存中分为一个“固定区”和若干个“覆盖区”。</p>
<p>需要常驻内存的段放在“固定区”中,调入后就不再调出（除非运行结束）</p>
<p>不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存</p>
<p>必须由程序员声明覆盖结构,操作系统完成自动覆盖。缺点: 对用户不透明,增加了用户编程负担。覆盖技术只用于早期的操作系统中，现在已成为历史。</p>
<h4 id="交换技术">交换技术</h4>
<p>交换(对换)技术的设计思想:内存空间紧张时,系统将内存中某些进程暂时换出外存,把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)</p>
<p>等同于 <a href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%B1%82%E6%AC%A1">中级调度</a></p>
<ol>
<li>具有对换功能的操作系统中,通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件,主要追求存储空间的利用率,因此对文件区空间的管理采用离散分配方式；对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度,因此对换区空间的管理主要追求换入换出速度,因此通常对换区采用连续分配方式(学过文件管理章节后即可理解)。总之,对换区的I/O速度比文件区的更快。</li>
<li>交换通常在许多进程运行且内存吃紧时进行,而系统负荷降低就暂停。例如:在发现许多进程运行时经常发生缺页,就说明内存紧张,此时可以换出一些进程；如果缺页率明显下降,就可以暂停换出。</li>
<li>可优先换出阻塞进程;可换出优先级低的进程;为了防止优先级低的进程在被调入内存后很快又被换出,有的系统还会考虑进程在内存的驻留时间……</li>
</ol>
<p>(注意: PCB会常驻内存,不会被换出外存)</p>
<h3 id="连续内存分配">连续内存分配</h3>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240128215535781.png" srcset="/img/loading.gif" lazyload alt="连续内存分配"></p>
<h3 id="动态分区分配算法">动态分区分配算法</h3>
<table>
<thead>
<tr>
<th>算法</th>
<th>算法思想</th>
<th>分区排列顺序</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>首次适应</td>
<td>优先使用更小的分区,以保留更多大分区空闲分区</td>
<td>以地址递增次序排列</td>
<td>会有更多的大分区被保留下来，更能满足大进程需求</td>
<td>会产生很多太小的、难以利用的碎片；算法开销大，回收分区后可能需要对空闲分区队列重新排序</td>
</tr>
<tr>
<td>最佳适应</td>
<td>优先使用更小的分区,以保留更多大分区</td>
<td>空闲分区以容量递增次序排列</td>
<td>会有更多的大分区被保留下来，更能满足大进程需求</td>
<td>会产生很多太小的、难以利用的碎片；算法开销大，回收分区后可能需要对空闲分区队列重新排序</td>
</tr>
<tr>
<td>最坏适应</td>
<td>优先使用更大的分区，以防止产生太小的不可用的碎片</td>
<td>空闲分区以容量递减次序排列</td>
<td>可以减少难以利用的小碎片</td>
<td>大分区容易被用完，不利于大进程；算法开销大（原因同上）</td>
</tr>
<tr>
<td>邻近适应</td>
<td>由首次适应演变而来，每次从上次查找结束位置开始查找</td>
<td>空闲分区以地址递增次序排列（可排列成循环链表）</td>
<td>不用每次都从低地址的小分区开始检索。算法开销小（原因同首次适应算法)</td>
<td>会使高地址的大分区也被用完</td>
</tr>
</tbody>
</table>
<h3 id="基本分页存储管理">基本分页存储管理</h3>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240128220441376.png" srcset="/img/loading.gif" lazyload alt="分页存储管理"></p>
<h3 id="两级页表">两级页表</h3>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240129075910196.png" srcset="/img/loading.gif" lazyload alt="两级页表"></p>
<h3 id="基本分段存储管理方式">基本分段存储管理方式</h3>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240209141643303.png" srcset="/img/loading.gif" lazyload alt="基本分段存储管理"></p>
<h3 id="虚拟内存管理">虚拟内存管理</h3>
<ul>
<li>先进先出FIFO算法
<ul>
<li>可能出现Belady异常，page fault数量并非单调降低</li>
</ul>
</li>
<li>OPT最优页面置换算法
<ul>
<li>替换在将来最长时间内不使用的页面</li>
<li>不可实现，因为不可能预测未来。仅用于理论推导，作为算法可能实现的性能上限</li>
</ul>
</li>
<li>LRU最小最近使用算法
<ul>
<li>替换在过去最长时间内不使用的页面</li>
<li>实现方式：
<ul>
<li>计数器，每次页面被引用了，都将当前时间写到页面的计数器中，替换时选择计数器值最小的页面</li>
<li>堆栈，将被访问的页面移动到栈顶，但是调整页面到栈顶的过程开销大</li>
</ul>
</li>
</ul>
</li>
<li>近似LRU算法
<ul>
<li>用一个8位的字节，记录最近8次访问每个页是否被访问</li>
<li>每次访问页面都将这个字节右移一位，如果页面被访问就在高位填1，否则填0</li>
</ul>
</li>
<li>第二次机会算法
<ul>
<li>每个页有一个标志位
<ul>
<li>0代表最近未使用，可用于替换</li>
<li>1代表最近使用，扫描到时修改为0</li>
</ul>
</li>
<li>想要替换页面时循环扫描所有页，扫描到0就替换</li>
</ul>
</li>
<li>增强型第二次机会算法
<ul>
<li>通过使用引用位和一致修改位（如果可用）来改进算法</li>
<li>采取有序配对（引用、修改）：
<ul>
<li>(0, 0)最近未使用未修改-要替换的最佳页面</li>
<li>(0, 1)最近未使用但已修改-不太好,必须在置换之前将页面写出；</li>
<li>(1, 0)最近使用但没有修改-可能很快会再次使用</li>
<li>(1, 1)最近使用和修改的-可能很快会再次使用，需要在更换前将页面写出；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>优化：页面缓冲</strong></p>
<p>始终保持一个空闲帧池</p>
<ul>
<li>当出现缺页错误时,会像以前一样选择一个牺牲帧</li>
<li>将页面读入空闲帧,选择要退出的牺牲帧并添加到空闲池</li>
<li>方便时,驱逐牺牲帧,无需等待写出牺牲帧</li>
<li>把必须串行的磁盘读和写操作变成可并行的（或对先后顺序不敏感的）</li>
</ul>
<p><strong>页面替换</strong></p>
<p>本地页面替换：替换进程自身的页面，不影响其他进程，可缓解系统抖动</p>
<p>优先级页面替换：高优先级进程可替换，低优先级进程等待</p>
<p><strong>工作集(Working Set)</strong></p>
<p>一个进程在最近给定时间长度内，所有访问到的页面总数</p>
<p>统计缺页错误率，如果小于给定阈值，减少进程的物理帧，如果大于阈值，增加进程的物理帧</p>
<p><strong>系统抖动</strong></p>
<p>进程的调页时间多于执行时间，那么这个进程就在抖动。或者说，进程的工作集（局部性访问的内存空间）大于总的物理内存大小</p>
<p>另外，操作系统检测到CPU利用率低时，可能会创建更多进程，这会造成恶性循环。</p>
<p>解决方案：</p>
<p>本地页面替换：替换进程自身的页面，不影响其他进程，可缓解系统抖动</p>
<p>优先级页面替换：高优先级进程可替换，低优先级进程等待</p>
<p>杀死并发的进程</p>
<h2 id="4-1-文件">4.1 文件</h2>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240129083459473.png" srcset="/img/loading.gif" lazyload alt="初识文件管理"></p>
<h3 id="文件的逻辑结构">文件的逻辑结构</h3>
<ul>
<li>无结构文件
<ul>
<li>由二进制流或字符流组成,无明显的逻辑结构</li>
</ul>
</li>
<li>有结构文件
<ul>
<li>由记录组成,分为定长记录、可变长记录</li>
</ul>
</li>
</ul>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240129085449954.png" srcset="/img/loading.gif" lazyload alt="有结构文件"></p>
<h3 id="文件目录">文件目录</h3>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240130210910236.png" srcset="/img/loading.gif" lazyload alt="文件目录"></p>
<h3 id="文件物理结构">文件物理结构</h3>
<p>用户给出要访问的逻辑块号,操作系统找到该文件对应的目录项(FCB) …</p>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240130223624530.png" srcset="/img/loading.gif" lazyload alt="文件物理结构"></p>
<h4 id="连续分配">连续分配</h4>
<p>物理块号=起始块号+逻辑块号</p>
<p>当然,还需要检查用户提供的逻辑块号是否合法(逻辑块号≥长度就不合法)</p>
<p>优点：可以随机访问磁盘块</p>
<p>缺点：</p>
<ol>
<li>物理上采用连续分配，存储空间利用率低，会产生难以利用的磁盘碎片可以用紧凑来处理碎片，但是需要耗费很大的时间代价。</li>
<li>物理上采用连续分配的文件不方便拓展。</li>
</ol>
<h4 id="隐式链接分配">隐式链接分配</h4>
<p>从目录项中找到起始块号(即0号块) ,将0号逻辑块读入内存，由此知道1号逻辑块存放的物理块号,于是读入1号逻辑块,再找到2号逻辑块的存放位置…以此类推。因此,读入i号逻辑块,总共需要i+1次磁盘I/O</p>
<p>优点:很方便文件拓展,不会有碎片问题,外存利用率高。</p>
<p>缺点:只支持顺序访问,不支持随机访问,查找效率低,指向下一个盘块的指针也需要耗费少量的存储空间。</p>
<h4 id="显式链接分配">显式链接分配</h4>
<p>把用于链接文件各物理块的指针显式地存放在一张表中，即文件分配表(FAT， File Allocation Table)。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存,并常驻内存。</p>
<p>优点:很方便文件拓展,不会有碎片问题,外存利用率高,并且支持随机访问。相比于隐式链接来说,地址转换时不需要访问磁盘,因此文件的访问效率更高。</p>
<p>缺点:文件分配表的需要占用一定的存储空间。</p>
<h4 id="索引分配">索引分配</h4>
<p>索引分配允许文件离散地分配在各个磁盘块中,系统会为每个文件建立一张索引表,索引表中记录了文件的各个逻辑块对应的物理块</p>
<p>（索引表的功能类似于内存管理中的页表—-建立逻辑页面到物理页之间的映射关系)。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。</p>
<p>索引分配方式可以支持<strong>随机访问****。文件拓展</strong>也很容易实现（只需要给文件分配一个空闲块,并增加一个索引表项即可)</p>
<p>若文件太大,索引表项太多,可以采取以下<strong>三种方法解决</strong>:</p>
<ol>
<li>
<p><strong>链接方案</strong>:如果索引表太大,一个索引块装不下,那么可以将多个索引块链接起来存放。</p>
<p>缺点:若文件很大,索引表很长,就需要将很多个索引块链接起来。想要找到i号索引块,必须先依次读入0~i-1号索引块,这就导致磁盘I/O次数过多,查找效率低下。</p>
</li>
<li>
<p><strong>多层索引</strong>：建立多层索引（原理类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。采用K层索引结构,且顶级索引表未调入内存,则访问一个数据块只需要K+1次读磁盘操作。</p>
<p>缺点:即使是小文件,访问一个数据块依然需要K+1次读磁盘</p>
</li>
<li>
<p><strong>混合索引</strong>:多种索引分配方式的结合。例如,一个文件的顶级索引表中,既包含直接地址索引(直接指向数据块),又包含一级间接索引(指向单层索引表)、还包含两级间接索引(指向两层索引表) 。</p>
<p>优点:对于小文件来说,访问一个数据块所需的读磁盘次数更少。</p>
</li>
</ol>
<h3 id="文件存储空间管理">文件存储空间管理</h3>
<h4 id="空闲表法">空闲表法</h4>
<p>如何分配磁盘块：与内存管理中的动态分区分配很类似,为一个文件分配连续的存储空间。同样<strong>可采用首次适应、最佳适应、最坏适应等算法</strong>来决定要为文件分配哪个区间。</p>
<p>如何回收磁盘块:与内存管理中的动态分区分配很类似,当回收某个存储区时需要有四种情况——①回收区的前后都没有相邻空闲区；②回收区的前后都是空闲区; 3回收区前面是空闲区; ④回收区后面是空闲区**。总之,回收时需要注意表项的合并问题**。</p>
<h4 id="空闲链表法">空闲链表法</h4>
<p><strong>空闲盘块链</strong>：以盘块为单位组成一条空闲链</p>
<p>操作系统保存着链头、链尾指针。</p>
<p>如何分配: 若某文件申请K个盘块,则从链头开始依次摘下K个盘块分配，并修改空闲链的链头指针。</p>
<p>如何回收：回收的盘块依次挂到链尾，并修改空闲链的链尾指针。</p>
<p><strong>空闲盘区链</strong>：以盘区为单位组成一条空闲链</p>
<p>操作系统保存着链头、链尾指针。</p>
<p>如何分配：若某文件申请 K个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区,分配给文件。若没有合适的连续空闲块,也可以将不同盘区的盘块同时分配给一个文件,注意分配后可能要修改相应的链指针、盘区大小等数据。</p>
<p>如何回收:若回收区和某个空闲盘区相邻,则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。</p>
<h4 id="位示图法">位示图法</h4>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>1</td>
<td>…</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>位示图:每个二进制位对应一个盘块。在本例中, &quot;0”代表盘块空闲,“1”代表盘块已分配。</p>
<p>如何分配：若文件需要K个块，①顺序扫描位示图，找到K个相邻或不相邻的&quot;0” ; ②根据字号、位号算出对应的盘块号,将相应盘块分配给文件;③将相应位设置为“1”。</p>
<p>如何回收:①根据回收的盘块号计算出对应的字号、位号;②将相应二进制位设为&quot;0”</p>
<h4 id="成组链接法">成组链接法</h4>
<p>UNIX采用的策略,适合大型文件系统。理解即可,不方便用文字描述的知识点也很难作为考题</p>
<h3 id="文件的基本操作">文件的基本操作</h3>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240209155208704.png" srcset="/img/loading.gif" lazyload alt="文件的基本操作"></p>
<h3 id="文件共享">文件共享</h3>
<p>基于索引结点的共享方式(硬链接)</p>
<p>知识回顾:索引结点,是一种文件目录瘦身策略。由于检索文件时只需用到文件名,因此可以将除了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名、索引结点指针。</p>
<p>索引结点中设置一个链接计数变量count,用于表示链接到本索引结点上的用户目录项数。</p>
<p>基于符号链的共享方式(软链接)</p>
<p>建立一个Link类型的文件，类似于windows的快捷方式</p>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240209161337293.png" srcset="/img/loading.gif" lazyload alt="文件共享"></p>
<h3 id="文件保护">文件保护</h3>
<ul>
<li>口令保护
<ul>
<li>为文件设置一个&quot;口令&quot;,用户想要访问文件时需要提供口令,由系统验证口令是否正确</li>
<li>实现开销小，但“口令”一般存放在FCB或索引结点中（也就是存放在系统中）因此不太安全</li>
</ul>
</li>
<li>加密保护
<ul>
<li>用一个&quot;密码&quot;对文件加密,用户想要访问文件时,需要提供相同的&quot;密码&quot;才能正确的解密</li>
<li>安全性高,但加密/解密需要耗费一定的时间(Eg:异或加密)</li>
</ul>
</li>
<li>访问控制
<ul>
<li>用一个访问控制表（ACL)记录各个用户（或各组用户)对文件的访问权限</li>
<li>对文件的访问类型可以分为：读/写/执行/删除 等</li>
<li>实现灵活，可以实现复杂的文件保护功能</li>
</ul>
</li>
</ul>
<h2 id="4-3-文件系统">4.3 文件系统</h2>
<h3 id="性质">性质</h3>
<p>文件系统的性质</p>
<ul>
<li>持久性</li>
<li>进程间共享</li>
<li>结构性，有复杂的组织结构</li>
</ul>
<p>文件的最小操作集合</p>
<ul>
<li>create</li>
<li>write</li>
<li>read</li>
<li>seek</li>
<li>delete</li>
<li>truncate（截断）</li>
</ul>
<p>打开文件不属于基本操作</p>
<h3 id="文件系统的层次结构">文件系统的层次结构</h3>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240209163315228.png" srcset="/img/loading.gif" lazyload alt="文件系统层次结构"></p>
<p>用一个例子来辅助记忆文件系统的层次结构：</p>
<p>假设某用户请求删除文件&quot;D:/工作目录/学生信息.xlsx&quot;的最后100条记录。</p>
<ol>
<li>用户需要通过操作系统提供的接口发出上述请求——用户接口</li>
<li>由于用户提供的是文件的存放路径,因此需要操作系统一层一层地查找目录,找到对应的目录项——文件目录系统</li>
<li>不同的用户对文件有不同的操作权限,因此为了保证安全，需要检查用户是否有访问权限一一存取控制模块（存取控制验证层）</li>
<li>验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址——逻辑文件系统与文件信息缓冲区</li>
<li>知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址——物理文件系统</li>
<li>要删除这条记录，必定要对磁盘设备发出请求——设备管理程序模块</li>
<li>删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收——辅助分配模块</li>
</ol>
<h3 id="文件系统的全局结构">文件系统的全局结构</h3>
<p>物理格式化后</p>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240209165138106.png" srcset="/img/loading.gif" lazyload alt="物理格式化"></p>
<p>逻辑格式化后</p>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240209165245088.png" srcset="/img/loading.gif" lazyload alt="逻辑格式化"></p>
<p>open系统调用打开文件的背后过程</p>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240209165546867.png" srcset="/img/loading.gif" lazyload alt="open系统调用打开文件的背后过程"></p>
<h3 id="虚拟文件系统">虚拟文件系统</h3>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240209170705209.png" srcset="/img/loading.gif" lazyload alt="虚拟文件系统"></p>
<p>虚拟文件系统的特点：</p>
<p>①向上层用户进程提供统一标准的系统调用接口,屏蔽底层具体文件系统的实现差异</p>
<p>②VFS要求下层的文件系统必须实现某些规定的函数功能,如: open/read/write.一个新的文件系统想要在某操作系统上被使用，就必须满足该操作系统VFS的要求</p>
<h4 id="文件系统挂载">文件系统挂载</h4>
<p>①在VFS中注册新挂载的文件系统。内存中的挂载表(mount table)包含每个文件系统的相关信息,包括文件系统类型、容量大小等。</p>
<p>②新挂载的文件系统，要向VFS提供一个函数地址列表</p>
<p>③将新文件系统加到挂载点（mountpoint) ,也就是将新文件系统挂载在某个父目录下</p>
<h2 id="5-1-I-O设备">5.1 I-O设备</h2>
<h3 id="大容量存储">大容量存储</h3>
<p>磁道 track</p>
<p>扇区 sector</p>
<p>柱面 cylinder</p>
<p>磁盘调度：</p>
<pre><code class=" mermaid">graph LR;
id1[等待设备可用] ===&gt; id2[等待通道可用]
id2 ===&gt; id3[寻道]
id3 ===&gt; id4[旋转延迟]
id4 ===&gt; id5[数据传送]
id6[设备忙] --&gt;id2
id6 --&gt;id5
</code></pre>
<p><strong>磁盘格式化</strong></p>
<p>高级格式化：格式化为文件系统，比如说ext4, fat32</p>
<p>低级格式化：格式化成扇区</p>
<h3 id="磁盘调度">磁盘调度</h3>
<p>空闲磁盘可以立即处理I/0请求，繁忙磁盘意味着工作必须排队</p>
<p>只需提供LBA(逻辑区块地址)，磁盘设备将其转化为物理的扇区位置，读写数据</p>
<p>调度算法：</p>
<ul>
<li>
<p>FIFO先来先服务</p>
<p>总是最公平的算法</p>
</li>
<li>
<p>PRI基于优先级：由操作系统设置优先级</p>
</li>
<li>
<p>SSTF:最短服务时间优先：选择使磁头臂从当前位置开始移动最少的磁盘I/O请求</p>
</li>
<li>
<p>SCAN扫描算法/电梯算法：磁头往一个固定的方向移动，直到访问到该方向的最后一个请求，就折返</p>
<p>是不公平的算法，因为不同请求序列的性能不同</p>
</li>
<li>
<p>CSCAN扫描算法：限制扫描只能沿一个方向，不允许双向扫描</p>
</li>
<li>
<p>N步SACN策略：准备若干长度为N的队列，队列内部使用SCAN算法扫描，队列间先来先服务</p>
</li>
<li>
<p>FSCAN：准备2个队列，每次对一个队列SCAN扫描，另一个队列接收新的任务但不执行</p>
</li>
</ul>
<p>进程更有可能在读的时候被阻塞，因为写的请求会收到互斥机制更严格的限制</p>
<p><strong>linux的截止时间调度器</strong></p>
<p>实现四个队列： 2个读取队列和2个写入队列</p>
<ul>
<li>1个读和1个写队列按LBA顺序排序,基本上实现了C-SCAN</li>
<li>按FCFS顺序排序的1个读队列和1个写队列</li>
<li>批量发送的所有I/O请求都按该队列的顺序排序</li>
<li>每批处理后,检查FCFS中是否有任何请求早于配置的时间(默认为500毫秒）
<ul>
<li>如果是，将为下一批I/O选择包含该请求的LBA队列</li>
</ul>
</li>
</ul>
<h3 id="RAID">RAID</h3>
<ul>
<li>RAID0: 没有冗余，将一个大文件分为多个strip，存在不同的磁盘，可以提高并行性，性能好</li>
<li>RAID1: 数据1:1复制，可靠性高，性能比RAID0快</li>
<li>RAID2: 在冗余磁盘存储海明码保证可靠性</li>
<li>RAID3: 在冗余磁盘使用Bit-interleaved parity保证可靠性，需要更少冗余盘</li>
<li>RAID4: 按照块Block-interleaved parity保证可靠性</li>
<li>RAID5: 和RAID4相似，将校验码分散到所有磁盘</li>
<li>RAID6: 和RAID4相似，校验码存2份，进一步保证可靠性</li>
</ul>
<h3 id="I-O设备的概念和分类">I-O设备的概念和分类</h3>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240213151318292.png" srcset="/img/loading.gif" lazyload alt="I-O设备的概念和分类"></p>
<h3 id="I-O控制器">I-O控制器</h3>
<p>I/O控制器的功能</p>
<ul>
<li>
<p>接受和识别CPU发出的命令</p>
<ul>
<li>如CPU发来的 read/write 命令，I/O控制器中会有相应的<strong>控制寄存器</strong>来存放命令和参数</li>
</ul>
</li>
<li>
<p>向CPU报告设备的状态</p>
<ul>
<li>I/O控制器中会有相应的<strong>状态寄存器</strong>，用于记录I/O设备的当前状态。如：1表示空闲，0表示忙碌</li>
</ul>
</li>
<li>
<p>数据交换</p>
<ul>
<li>I/O控制器中会设置相应的<strong>数据寄存器</strong>。输出时，数据寄存器用于暂存CPU发来的数据，之后再由控制器传送设备。输入时，数据寄存器用于暂存设备发来的数据，之后CPU从数据寄存器中取走数据。</li>
</ul>
</li>
<li>
<p>地址识别</p>
<ul>
<li>类似于内存的地址，为了区分设备控制器中的各个寄存器，也需要给各个寄存器设置一个特定的“地址”。I/O控制器通过CPU提供的“地址”来判断CPU要读/写的是哪个寄存器</li>
</ul>
</li>
</ul>
<p>组成</p>
<ul>
<li>CPU与控制器之间的接口(实现控制器与CPU之间的通信)</li>
<li>I/O逻辑(负责识别CPU发出的命令,并向设备发出命令)</li>
<li>控制器与设备之间的接口（实现控制器与设备之间的通信）</li>
</ul>
<p>两种寄存器编制方式</p>
<ul>
<li>内存映射I/O</li>
<li>寄存器独立编制</li>
</ul>
<h3 id="I-O控制方式">I-O控制方式</h3>
<p>计组学过，这里简略一点</p>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240213154238727.png" srcset="/img/loading.gif" lazyload alt="I-O控制方式"></p>
<h4 id="轮询式">轮询式</h4>
<p>对于I/O的每个字节</p>
<ol>
<li>从状态寄存器读取忙位,直到该位清零</li>
<li>主机设置读或写位,如果写入,则将数据复制到数据输出寄存器中</li>
<li>主机设置命令就绪位</li>
<li>控制器设置忙位</li>
<li>控制器读取命令寄存器，并看到命令。从数据输出寄存器中读取一个字节，并向设备执行I/O操作</li>
<li>传输完成时,控制器清除忙位、错误位、命令准备位</li>
</ol>
<h4 id="中断式">中断式</h4>
<pre><code class=" mermaid">graph TD;
id1[设备驱动初始化I/O请求] --CPU在执行一条指令后检查中断请求--&gt;id2[CPU收到中断请求,分发给相应中断服务例程]
id2 --&gt; id3[中断服务例程进行中断处理]
id3 --&gt; id4[CPU恢复被中断进程的执行]
id4 --&gt; id1
id1 ==&gt; id5(IO控制器初始化IO操作)
id5 ==&gt; id6(IO控制器在操作完成或错误后产生中断)
id6 ==&gt; id2
</code></pre>
<h4 id="DMA">DMA</h4>
<p>DMA控制器被集成在CPU上</p>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240605103756235.png" srcset="/img/loading.gif" lazyload alt="DMA过程"></p>
<ul>
<li>
<p>CPU干预的频率：仅在传送一个或多个数据块的开始和结束时，才需要CPU干预</p>
</li>
<li>
<p>数据传送的单位：每次读/写一个或多个块(注意:每次读写的只能是连续的多个块,且这些块读入内存后在内存中也必须是连续的)</p>
</li>
<li>
<p>数据的流向(不再需要经过CPU)</p>
<ul>
<li>读操作（数据输入）: I/O设备→内存</li>
<li>写操作（数据输出）：内存→I/O设备</li>
</ul>
</li>
<li>
<p>主要缺点和主要优点</p>
<ul>
<li>优点:数据传输以“块”为单位, CPU介入频率进一步降低。数据的传输不再需要先经过CPU再写入内存,数据传输效率进一步增加。CPU和I/O设备的并行性得到提升。</li>
<li>缺点: CPU每发出一条I/O指令,只能读/写一个或多个连续的数据块。</li>
</ul>
</li>
</ul>
<h4 id="通道">通道</h4>
<p>通道：一种硬件，可以理解为是“弱鸡版的CPU”。通道可以识别并执行一系列通道指令。与CPU相比，通道可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道与CPU共享内存</p>
<ul>
<li>CPU干预的频率
<ul>
<li>极低,通道会根据CPU的指示执行相应的通道程序,只有完成一组数据块的读/写后才需要发出中断信号,请求CPU干预</li>
</ul>
</li>
<li>数据传送的单位
<ul>
<li>每次读/写一组数据块</li>
</ul>
</li>
<li>数据的流向(在通道的控制下进行)
<ul>
<li>读操作（数据输入): I/O设备→内存</li>
<li>写操作（数据输出): 内存→I/O设备</li>
</ul>
</li>
<li>主要缺点和主要优点
<ul>
<li>缺点:实现复杂,需要专门的通道硬件支持</li>
<li>优点: CPU、通道、I/O设备可并行工作,资源利用率很高。</li>
</ul>
</li>
</ul>
<h3 id="I-O软件层次结构">I-O软件层次结构</h3>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240213160921583.png" srcset="/img/loading.gif" lazyload alt="I-O软件层次结构"></p>
<p>逻辑设备表(LUT)</p>
<p>示例：</p>
<table>
<thead>
<tr>
<th>逻辑设备名</th>
<th>物理设备名</th>
<th>驱动程序入口地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>/dev/打印机1</td>
<td>3</td>
<td>1024</td>
</tr>
<tr>
<td>/dev/打印机2</td>
<td>5</td>
<td>2046</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<h4 id="输入输出应用程序接口">输入输出应用程序接口</h4>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240213162605071.png" srcset="/img/loading.gif" lazyload alt="输入输出应用程序接口"></p>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240213162503821.png" srcset="/img/loading.gif" lazyload alt="网络传输"></p>
<h4 id="阻塞-非阻塞I-O">阻塞/非阻塞I-O</h4>
<ul>
<li>阻塞I/O： 应用程序发出I/O系统调用，进程需转为阻塞态筹待。
<ul>
<li>eg：字符设备接口——从键盘读一个字符 get</li>
</ul>
</li>
<li>非阻塞I/O应用程序发出I/O系统调用。
<ul>
<li>系统调用可迅速返回,进程无需阻塞等待。</li>
<li>eg：块设备接口——往磁盘写数据 write</li>
</ul>
</li>
</ul>
<h2 id="5-2-IO核心子系统">5.2 IO核心子系统</h2>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240213164745333.png" srcset="/img/loading.gif" lazyload alt="IO核心子系统"></p>
<p>IO核心子系统实际要实现上图中间三层的功能</p>
<p>考研中，我们需要重点理解和掌握的功能是: I/O调度、设备保护、假脱机技术（SPOOLing技术）、设备分配与回收、缓冲区管理（即缓冲与高速缓存）</p>
<p><strong>设备保护</strong>：</p>
<p>操作系统需要实现文件保护功能,不同的用户对各个文件有不同的访问权限(如:只读、读和写等）。</p>
<p>在UNIX系统中,设备被看做是一种特殊的文件,每个设备也会有对应的FCB。当用户请求访问某个设备时,系统根据FCB中记录的信息来判断该用户是否有相应的访问权限,以此实现“设备保护”的功能。(参考“文件保护”小节)</p>
<h3 id="假脱机技术">假脱机技术</h3>
<ul>
<li>又叫SPOOLing技术，用软件的方式模拟脱机技术</li>
<li>输入井和输出井——模拟脱机输入/输出时的磁带</li>
<li>输入进程和输出进程——模拟脱机输入/输出时的外围控制机</li>
<li>输入缓冲区和输出缓冲区——内存中的缓冲区，输入、输出时的“中转站”</li>
</ul>
<p>用于共享打印机</p>
<p>当多个用户进程提出输出打印的请求时,系统会答应它们的请求,但是并不是真正把打印机分配给他们,而是由假脱机管理进程为每个进程做两件事:</p>
<p>(1)在磁盘输出井中为进程申请一个空闲缓冲区(也就是说,这个缓冲区是在磁盘上的) ,并将要打印的数据送入其中；</p>
<p>(2)为用户进程申请一张空白的打印请求表,并将用户的打印请求填入表中(其实就是用来说明用户的打印数据存放位置等信息的)，再将该表挂到假脱机文件队列上。</p>
<p>当打印机空闲时,输出进程会从文件队列的队头取出一张打印请求表,并根据表中的要求将要打印的数据从输出井传送到输出缓冲区,再输出到打印机进行打印。用这种方式可依次处理完全部的打印任务</p>
<p>虽然系统中只有一个台打印机,但每个进程提出打印请求时,系统都会为在输出井中为其分配一个存储区(相当于分配了一个逻辑设备),使每个用户进程都觉得自己在独占一台打印机,从而实现对打印机的共享。</p>
<p>SPOOLing技术可以把一台物理设备虚拟成逻辑上的多台设备,可将独占式设备改造成共享设备。</p>
<h3 id="设备的分配与回收">设备的分配与回收</h3>
<p>设备的固有属性可分为三种：独占设备、共享设备、虚拟设备。</p>
<ul>
<li>独占设备: 一个时段只能分配给一个进程（如打印机）</li>
<li>共享设备: 可同时分配给多个进程使用（如磁盘) ,各进程往往是宏观上同时共享使用设备,而微观上交替使用。</li>
<li>虚拟设备: 采用SPOOLing技术将独占设备改造成虚拟的共享设备,可同时分配给多个进程使用(如采用SPOOLing技术实现的共享打印机)</li>
</ul>
<p>设备的分配算法：</p>
<ul>
<li>先来先服务</li>
<li>优先级高者优先</li>
<li>短任务优先</li>
</ul>
<p>从进程运行的安全性上考虑,设备分配有两种方式:</p>
<ul>
<li>安全分配方式:为进程分配一个设备后就将进程阻塞,本次1/0完成后才将进程唤醒。
<ul>
<li>一个时段内每个进程只能使用一个设备</li>
<li>优点：破坏了“请求和保持”条件，不会死锁</li>
<li>缺点：对于一个进程来说，CPU和I/O设备只能串行工作</li>
</ul>
</li>
<li>不安全分配方式:进程发出I/O请求后,系统为其分配I/O设备,进程可继续执行,之后还可以发出新的I/O请求。只有某个I/O请求得不到满足时才将进程阻塞。
<ul>
<li>一个进程可以同时使用多个设备</li>
<li>优点:进程的计算任务和I/O任务可以并行处理,使进程迅速推进</li>
<li>缺点:有可能发生死锁(死锁避免、死锁的检测和解除)</li>
</ul>
</li>
</ul>
<p>静态分配和动态分配：</p>
<ul>
<li>静态分配:进程运行前为其分配全部所需资源,运行结束后归还资源
<ul>
<li>破坏了“请求和保持”条件，不会发生死锁</li>
</ul>
</li>
<li>动态分配：进程运行过程中动态申请设备资源</li>
</ul>
<h4 id="设备分配管理中的数据结构">设备分配管理中的数据结构</h4>
<p><img src="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20240214133219620.png" srcset="/img/loading.gif" lazyload alt="设备、控制器、通道之间的关系"></p>
<p>设备控制表（DCT）：系统为每个设备配置一张DCT，用于记录设备情况</p>
<ul>
<li>设备类型如：打印机/扫描仪/键盘</li>
<li>设备标识符: 即物理设备名,系统中的每个设备的物理设备名唯一</li>
<li>设备状态: 忙碌/空闲/故障…</li>
<li>指向控制器表的指针: 每个设备由一个控制器控制，该指针可找到相应控制器的信息</li>
<li>重复执行次数或时间: 当重复执行多次I/O操作后仍不成功，才认为此次I/O失败</li>
<li>设备队列的队首指针: 指向正在等待该设备的进程队列（由进程PCB组成队列)</li>
</ul>
<p>控制器控制表(COCT) :每个设备控制器都会对应一张COCT。操作系统根据COCT的信息对控制器进行操作和管理。</p>
<ul>
<li>控制器标识符: 各个控制器的唯一ID</li>
<li>控制器状态: 忙碌/空闲/故障…</li>
<li>指向通道表的指针: 每个控制器由一个通道控制，该指针可找到相应通道的信息</li>
<li>控制器队列的队首指针</li>
<li>控制器队列的队尾指针: 指向正在等待该控制器的进程队列(由进程PCB组成队列)</li>
</ul>
<p>通道控制表(CHCT) :每个通道都会对应一张CHCT。操作系统根据CHCT的信息对通道进行操作和管理。</p>
<ul>
<li>通道标识符: 各个通道的唯一ID</li>
<li>通道状态: 忙碌/空闲/故障…</li>
<li>与通道连接的控制器表首址: 可通过该指针找到该通道管理的所有控制器相关信息（COCT）</li>
<li>通道队列的队首指针</li>
<li>通道队列的队尾指针: 指向正在等待该通道的进程队列（由进程PCB组成队列</li>
</ul>
<p>系统设备表(SDT) :记录了系统中全部设备的情况,每个设备对应一个表目。</p>
<p>每个表目包括：设备类型、设备标识符、DCT（设备控制表)、驱动程序入口</p>
<h4 id="设备分配的步骤">设备分配的步骤</h4>
<p>①根据进程请求的逻辑设备名查找SDT（注：用户编程时提供的逻辑设备名其实就是“设备类型”）</p>
<p>②查找SDT,找到用户进程指定类型的、并且空闲的设备,将其分配给该进程。操作系统在逻辑设备表(LUT)中新增一个表项。</p>
<p>③根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</p>
<p>④根据COCT找到CHCT,若通道忙碌则将进程PCB挂到通道等待队列中,不忙碌则将通道分配给进程。</p>
<p>重复逻辑设备表的设置问题</p>
<ul>
<li>
<p>整个系统只有一张LUT：各用户所用的逻辑设备名不允许</p>
</li>
<li>
<p>每个用户一张LUT:各个用户的逻辑设备名可重复</p>
</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/courses/" class="category-chain-item">courses</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>操作系统笔记</div>
      <div>https://blog.algorithmpark.xyz/2024/01/19/operating-system/index/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>CJL</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年1月19日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2024年6月17日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/01/30/language/pytorch/index/" title="pytorch">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">pytorch</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/11/25/probability-and-statistics/" title="probability-and-statistics">
                        <span class="hidden-mobile">probability-and-statistics</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
    <div id="giscus" class="giscus"></div>
    <script type="text/javascript">
      Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"algorithmpark/algorithmpark.github.io","repo-id":"R_kgDOKIc7hQ","category":"Announcements","category-id":"DIC_kwDOKIc7hc4CdDq9","theme-light":"dark","theme-dark":"dark","mapping":"pathname","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'dark';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  




  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://blog.algorithmpark.xyz" target="_blank" rel="nofollow noopener"><span>AlgorithmPark</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/CJL196" target="_blank" rel="nofollow noopener"><span>CJL</span></a> <p><a href="https://icp.gov.moe/?keyword=20240042" target="_blank">萌ICP备20240042号</a></p> <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  var relativeDate = function() {
    var updatedTime = document.getElementById('updated-time');
    if (updatedTime) {
      var text = updatedTime.textContent;
      var reg = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/;
      var matchs = text.match(reg);
      if (matchs) {
        var relativeTime = moment(matchs[0]).fromNow();
        updatedTime.textContent = text.replace(reg, relativeTime);
      }
      updatedTime.style.display = '';
    }
  };
  Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/moment.min.js', function() {
    if (!'zh-cn'.startsWith('en')) {
      Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/locale/zh-cn.min.js', function() {
        relativeDate();
      });
    } else {
      relativeDate();
    }
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
